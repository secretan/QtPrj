C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE FW
OBJECT MODULE PLACED IN .\Objects\fw.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\src\fw.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND CODE LISTINCLUDE
                    - SYMBOLS PRINT(.\Listings\fw.lst) TABS(2) PREPRINT(.\Listings\fw.i) OBJECT(.\Objects\fw.obj)

line level    source

   1          //-----------------------------------------------------------------------------
   2          //   File:      fw.c
   3          //   Contents:  Firmware frameworks task dispatcher and device request parser
   4          //
   5          // $Archive: /USB/Examples/FX2LP/bulkext/fw.c $
   6          // $Date: 3/23/05 2:53p $
   7          // $Revision: 8 $
   8          //
   9          //
  10          //-----------------------------------------------------------------------------
  11          // Copyright 2003, Cypress Semiconductor Corporation
  12          //-----------------------------------------------------------------------------
  13          
  14          
  15          #include "fx2.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //   File:      FX2.h
   3      =1  //   Contents:  EZ-USB FX2/FX2LP/FX1 constants, macros, datatypes, globals, and library
   4      =1  //              function prototypes.
   5      =1  //
   6      =1  // $Archive: /USB/Target/Inc/Fx2.h $
   7      =1  // $Date: 3/23/05 2:30p $
   8      =1  // $Revision: 16 $
   9      =1  //
  10      =1  //   Copyright (c) 2005 Cypress Semiconductor, All rights reserved
  11      =1  //-----------------------------------------------------------------------------
  12      =1  #ifndef FX2_H     //Header sentry
  13      =1  #define FX2_H
  14      =1  
  15      =1  #define INTERNAL_DSCR_ADDR 0x0080   // Relocate Descriptors to 0x80
  16      =1  #define bmSTRETCH 0x07
  17      =1  #define FW_STRETCH_VALUE 0x0      // Set stretch to 0 in frameworks
  18      =1  
  19      =1  #define ENABLE_7_SEG_DISPLAY
  20      =1  extern int start_7_seg_display;
  21      =1  
  22      =1  //-----------------------------------------------------------------------------
  23      =1  // Constants
  24      =1  //-----------------------------------------------------------------------------
  25      =1  #define   TRUE    1
  26      =1  #define FALSE   0
  27      =1  
  28      =1  #define bmBIT0   0x01
  29      =1  #define bmBIT1   0x02
  30      =1  #define bmBIT2   0x04
  31      =1  #define bmBIT3   0x08
  32      =1  #define bmBIT4   0x10
  33      =1  #define bmBIT5   0x20
  34      =1  #define bmBIT6   0x40
  35      =1  #define bmBIT7   0x80
  36      =1  
  37      =1  #define DEVICE_DSCR      0x01      // Descriptor type: Device
  38      =1  #define CONFIG_DSCR      0x02      // Descriptor type: Configuration
  39      =1  #define STRING_DSCR      0x03      // Descriptor type: String
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 2   

  40      =1  #define INTRFC_DSCR      0x04      // Descriptor type: Interface
  41      =1  #define ENDPNT_DSCR      0x05      // Descriptor type: End Point
  42      =1  #define DEVQUAL_DSCR     0x06      // Descriptor type: Device Qualifier
  43      =1  #define OTHERSPEED_DSCR  0x07      // Descriptor type: Other Speed Configuration
  44      =1  
  45      =1  #define bmBUSPWR  bmBIT7         // Config. attribute: Bus powered
  46      =1  #define bmSELFPWR bmBIT6         // Config. attribute: Self powered
  47      =1  #define bmRWU     bmBIT5         // Config. attribute: Remote Wakeup
  48      =1  
  49      =1  #define bmEPOUT   bmBIT7
  50      =1  #define bmEPIN    0x00
  51      =1  
  52      =1  #define EP_CONTROL   0x00        // End Point type: Control
  53      =1  #define EP_ISO       0x01        // End Point type: Isochronous
  54      =1  #define EP_BULK      0x02        // End Point type: Bulk
  55      =1  #define EP_INT       0x03        // End Point type: Interrupt
  56      =1  
  57      =1  #define SUD_SIZE            8      // Setup data packet size
  58      =1  
  59      =1  //////////////////////////////////////////////////////////////////////////////
  60      =1  //Added for HID
  61      =1  
  62      =1  #define SETUP_MASK        0x60  //Used to mask off request type
  63      =1  #define SETUP_STANDARD_REQUEST  0   //Standard Request
  64      =1  #define SETUP_CLASS_REQUEST   0x20  //Class Request
  65      =1  #define SETUP_VENDOR_REQUEST  0x40  //Vendor Request
  66      =1  #define SETUP_RESERVED_REQUEST  0x60  //Reserved or illegal request
  67      =1  
  68      =1  //////////////////////////////////////////////////////////////////////////////
  69      =1  
  70      =1  
  71      =1  #define SC_GET_STATUS         0x00   // Setup command: Get Status
  72      =1  #define SC_CLEAR_FEATURE      0x01   // Setup command: Clear Feature
  73      =1  #define SC_RESERVED            0x02   // Setup command: Reserved
  74      =1  #define SC_SET_FEATURE         0x03   // Setup command: Set Feature
  75      =1  #define SC_SET_ADDRESS         0x05   // Setup command: Set Address
  76      =1  #define SC_GET_DESCRIPTOR      0x06   // Setup command: Get Descriptor
  77      =1  #define SC_SET_DESCRIPTOR      0x07   // Setup command: Set Descriptor
  78      =1  #define SC_GET_CONFIGURATION   0x08   // Setup command: Get Configuration
  79      =1  #define SC_SET_CONFIGURATION   0x09   // Setup command: Set Configuration
  80      =1  #define SC_GET_INTERFACE      0x0a   // Setup command: Get Interface
  81      =1  #define SC_SET_INTERFACE      0x0b   // Setup command: Set Interface
  82      =1  #define SC_SYNC_FRAME         0x0c   // Setup command: Sync Frame
  83      =1  #define SC_ANCHOR_LOAD         0xa0   // Setup command: Anchor load
  84      =1     
  85      =1  #define GD_DEVICE          0x01  // Get descriptor: Device
  86      =1  #define GD_CONFIGURATION   0x02  // Get descriptor: Configuration
  87      =1  #define GD_STRING          0x03  // Get descriptor: String
  88      =1  #define GD_INTERFACE       0x04  // Get descriptor: Interface
  89      =1  #define GD_ENDPOINT        0x05  // Get descriptor: Endpoint
  90      =1  #define GD_DEVICE_QUALIFIER 0x06  // Get descriptor: Device Qualifier
  91      =1  #define GD_OTHER_SPEED_CONFIGURATION 0x07  // Get descriptor: Other Configuration
  92      =1  #define GD_INTERFACE_POWER 0x08  // Get descriptor: Interface Power
  93      =1  #define GD_HID              0x21  // Get descriptor: HID
  94      =1  #define GD_REPORT          0x22 // Get descriptor: Report
  95      =1  
  96      =1  #define GS_DEVICE          0x80  // Get Status: Device
  97      =1  #define GS_INTERFACE       0x81  // Get Status: Interface
  98      =1  #define GS_ENDPOINT        0x82  // Get Status: End Point
  99      =1  
 100      =1  #define FT_DEVICE          0x00  // Feature: Device
 101      =1  #define FT_ENDPOINT        0x02  // Feature: End Point
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 3   

 102      =1  
 103      =1  #define I2C_IDLE              0     // I2C Status: Idle mode
 104      =1  #define I2C_SENDING           1     // I2C Status: I2C is sending data
 105      =1  #define I2C_RECEIVING         2     // I2C Status: I2C is receiving data
 106      =1  #define I2C_PRIME             3     // I2C Status: I2C is receiving the first byte of a string
 107      =1  #define I2C_STOP              5     // I2C Status: I2C waiting for stop completion
 108      =1  #define I2C_BERROR            6     // I2C Status: I2C error; Bit Error
 109      =1  #define I2C_NACK              7     // I2C Status: I2C error; No Acknowledge
 110      =1  #define I2C_OK                8     // I2C positive return code
 111      =1  #define I2C_WAITSTOP          9     // I2C Status: Wait for STOP complete
 112      =1  
 113      =1  /*-----------------------------------------------------------------------------
 114      =1     Macros
 115      =1  -----------------------------------------------------------------------------*/
 116      =1  
 117      =1  #define MSB(word)      (BYTE)(((WORD)(word) >> 8) & 0xff)
 118      =1  #define LSB(word)      (BYTE)((WORD)(word) & 0xff)
 119      =1  
 120      =1  #define SWAP_ENDIAN(word)   ((BYTE*)&word)[0] ^= ((BYTE*)&word)[1];\
 121      =1                       ((BYTE*)&word)[1] ^= ((BYTE*)&word)[0];\
 122      =1                       ((BYTE*)&word)[0] ^= ((BYTE*)&word)[1]
 123      =1  
 124      =1  #define EZUSB_IRQ_ENABLE()   EUSB = 1
 125      =1  #define EZUSB_IRQ_DISABLE()   EUSB = 0
 126      =1  #define EZUSB_IRQ_CLEAR()   EXIF &= ~0x10      // IE2_
 127      =1  
 128      =1  #define EZUSB_STALL_EP0()            EP0CS |= bmEPSTALL
 129      =1  
 130      =1  // WRITEDELAY() has been replaced by SYNCDELAY; macro in fx2sdly.h
 131      =1  // ...it is here for backwards compatibility...
 132      =1  
 133      =1  // the WRITEDELAY macro compiles to the time equivalent of 3 NOPs.
 134      =1  // It is used in the frameworks to allow for write recovery time
 135      =1  // requirements of certain registers.  This is only necessary for
 136      =1  // EZ-USB FX parts.  See the EZ-USB FX TRM for
 137      =1  // more information on write recovery time issues.
 138      =1  #define WRITEDELAY() {char writedelaydummy = 0;}
 139      =1  // if this firmware will never run on an EZ-USB FX part replace
 140      =1  // with:
 141      =1  // #define WRITEDELAY()
 142      =1  
 143      =1  // macro to reset and endpoint data toggle
 144      =1  #define EZUSB_RESET_DATA_TOGGLE(ep)     TOGCTL = (((ep & 0x80) >> 3) + (ep & 0x0F));\
 145      =1                                          TOGCTL |= bmRESETTOGGLE
 146      =1  
 147      =1  
 148      =1  #define EZUSB_ENABLE_RSMIRQ()      (EICON |= 0x20)      // Enable Resume Interrupt (EPFI_)
 149      =1  #define EZUSB_DISABLE_RSMIRQ()      (EICON &= ~0x20)   // Disable Resume Interrupt (EPFI_)
 150      =1  #define EZUSB_CLEAR_RSMIRQ()      (EICON &= ~0x10)   // Clear Resume Interrupt Flag (PFI_)
 151      =1  
 152      =1  #define EZUSB_GETI2CSTATUS()      (I2CPckt.status)
 153      =1  #define EZUSB_CLEARI2CSTATUS()      if((I2CPckt.status == I2C_BERROR) || (I2CPckt.status == I2C_NACK))\
 154      =1                                I2CPckt.status = I2C_IDLE;
 155      =1  
 156      =1  #define EZUSB_ENABLEBP()         (BREAKPT |= bmBPEN)
 157      =1  #define EZUSB_DISABLEBP()         (BREAKPT &= ~bmBPEN)
 158      =1  #define EZUSB_CLEARBP()            (BREAKPT |= bmBREAK)
 159      =1  #define EZUSB_BP(addr)            BPADDRH = (BYTE)(((WORD)addr >> 8) & 0xff);\      
 160      =1                                    BPADDRL = (BYTE)addr
 161      =1  
 162      =1  #define EZUSB_EXTWAKEUP()      (((WAKEUPCS & bmWU2) && (WAKEUPCS & bmWU2EN)) ||\
 163      =1                                  ((WAKEUPCS & bmWU) &&  (WAKEUPCS & bmWUEN)))
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 4   

 164      =1  
 165      =1  #define EZUSB_HIGHSPEED()      (USBCS & bmHSM)
 166      =1  
 167      =1  //-----------------------------------------------------------------------------
 168      =1  // Datatypes
 169      =1  //-----------------------------------------------------------------------------
 170      =1  typedef unsigned char   BYTE;
 171      =1  typedef unsigned short   WORD;
 172      =1  typedef unsigned long   DWORD;
 173      =1  typedef bit            BOOL;
 174      =1  
 175      =1  #define  INT0_VECT   0
 176      =1  #define  TMR0_VECT   1
 177      =1  #define  INT1_VECT   2
 178      =1  #define  TMR1_VECT   3
 179      =1  #define  COM0_VECT   4
 180      =1  #define  TMR2_VECT   5
 181      =1  #define  WKUP_VECT   6
 182      =1  #define  COM1_VECT   7
 183      =1  #define  USB_VECT    8
 184      =1  #define  I2C_VECT    9
 185      =1  #define  INT4_VECT   10
 186      =1  #define  INT5_VECT   11
 187      =1  #define  INT6_VECT   12
 188      =1  
 189      =1  
 190      =1  typedef struct
 191      =1  {
 192      =1     BYTE   length;
 193      =1     BYTE   type;
 194      =1  }DSCR;
 195      =1  
 196      =1  typedef struct            // Device Descriptor
 197      =1  {
 198      =1     BYTE   length;         // Descriptor length ( = sizeof(DEVICEDSCR) )
 199      =1     BYTE   type;         // Decriptor type (Device = 1)
 200      =1     BYTE   spec_ver_minor;   // Specification Version (BCD) minor
 201      =1     BYTE   spec_ver_major;   // Specification Version (BCD) major
 202      =1     BYTE   dev_class;      // Device class
 203      =1     BYTE   sub_class;      // Device sub-class
 204      =1     BYTE   protocol;      // Device sub-sub-class
 205      =1     BYTE   max_packet;      // Maximum packet size
 206      =1     WORD   vendor_id;      // Vendor ID
 207      =1     WORD   product_id;      // Product ID
 208      =1     WORD   version_id;      // Product version ID
 209      =1     BYTE   mfg_str;      // Manufacturer string index
 210      =1     BYTE   prod_str;      // Product string index
 211      =1     BYTE   serialnum_str;   // Serial number string index
 212      =1     BYTE   configs;      // Number of configurations
 213      =1  }DEVICEDSCR;
 214      =1  
 215      =1  typedef struct            // Device Qualifier Descriptor
 216      =1  {
 217      =1     BYTE   length;         // Descriptor length ( = sizeof(DEVICEQUALDSCR) )
 218      =1     BYTE   type;         // Decriptor type (Device Qualifier = 6)
 219      =1     BYTE   spec_ver_minor;   // Specification Version (BCD) minor
 220      =1     BYTE   spec_ver_major;   // Specification Version (BCD) major
 221      =1     BYTE   dev_class;      // Device class
 222      =1     BYTE   sub_class;      // Device sub-class
 223      =1     BYTE   protocol;      // Device sub-sub-class
 224      =1     BYTE   max_packet;      // Maximum packet size
 225      =1     BYTE   configs;      // Number of configurations
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 5   

 226      =1     BYTE  reserved0;
 227      =1  }DEVICEQUALDSCR;
 228      =1  
 229      =1  typedef struct
 230      =1  {
 231      =1     BYTE   length;         // Configuration length ( = sizeof(CONFIGDSCR) )
 232      =1     BYTE   type;         // Descriptor type (Configuration = 2)
 233      =1     WORD   config_len;      // Configuration + End Points length
 234      =1     BYTE   interfaces;      // Number of interfaces
 235      =1     BYTE   index;         // Configuration number
 236      =1     BYTE   config_str;      // Configuration string
 237      =1     BYTE   attrib;         // Attributes (b7 - buspwr, b6 - selfpwr, b5 - rwu
 238      =1     BYTE   power;         // Power requirement (div 2 ma)
 239      =1  }CONFIGDSCR;
 240      =1  
 241      =1  typedef struct
 242      =1  {
 243      =1     BYTE   length;         // Interface descriptor length ( - sizeof(INTRFCDSCR) )
 244      =1     BYTE   type;         // Descriptor type (Interface = 4)
 245      =1     BYTE   index;         // Zero-based index of this interface
 246      =1     BYTE   alt_setting;   // Alternate setting
 247      =1     BYTE   ep_cnt;         // Number of end points 
 248      =1     BYTE   class;         // Interface class
 249      =1     BYTE   sub_class;      // Interface sub class
 250      =1     BYTE   protocol;      // Interface sub sub class
 251      =1     BYTE   interface_str;   // Interface descriptor string index
 252      =1  }INTRFCDSCR;
 253      =1  
 254      =1  typedef struct
 255      =1  {
 256      =1     BYTE   length;         // End point descriptor length ( = sizeof(ENDPNTDSCR) )
 257      =1     BYTE   type;         // Descriptor type (End point = 5)
 258      =1     BYTE   addr;         // End point address
 259      =1     BYTE   ep_type;      // End point type
 260      =1     BYTE   mp_L;         // Maximum packet size
 261      =1     BYTE   mp_H;
 262      =1     BYTE   interval;      // Interrupt polling interval
 263      =1  }ENDPNTDSCR;
 264      =1  
 265      =1  typedef struct
 266      =1  {
 267      =1     BYTE   length;         // String descriptor length
 268      =1     BYTE   type;         // Descriptor type
 269      =1  }STRINGDSCR;
 270      =1  
 271      =1  typedef struct
 272      =1  {
 273      =1     BYTE   cntrl;         // End point control register
 274      =1     BYTE   bytes;         // End point buffer byte count
 275      =1  }EPIOC;
 276      =1  
 277      =1  typedef struct 
 278      =1  {
 279      =1     BYTE   length;
 280      =1     BYTE   *dat;
 281      =1     BYTE   count;
 282      =1     BYTE   status;
 283      =1  }I2CPCKT;
 284      =1  
 285      =1  //-----------------------------------------------------------------------------
 286      =1  // Globals
 287      =1  //-----------------------------------------------------------------------------
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 6   

 288      =1  extern code BYTE   USB_AutoVector;
 289      =1  
 290      =1  extern WORD   pDeviceDscr;
 291      =1  extern WORD   pDeviceQualDscr;
 292      =1  extern WORD   pHighSpeedConfigDscr;
 293      =1  extern WORD   pFullSpeedConfigDscr; 
 294      =1  extern WORD   pConfigDscr;
 295      =1  extern WORD   pOtherConfigDscr;
 296      =1  extern WORD   pStringDscr;
 297      =1  
 298      =1  extern code DEVICEDSCR        DeviceDscr;
 299      =1  extern code DEVICEQUALDSCR    DeviceQualDscr;
 300      =1  extern code CONFIGDSCR        HighSpeedConfigDscr;
 301      =1  extern code CONFIGDSCR        FullSpeedConfigDscr;
 302      =1  extern code STRINGDSCR        StringDscr;
 303      =1  extern code DSCR              UserDscr;
 304      =1  
 305      =1  extern I2CPCKT   I2CPckt;
 306      =1  
 307      =1  //-----------------------------------------------------------------------------
 308      =1  // Function Prototypes
 309      =1  //-----------------------------------------------------------------------------
 310      =1  
 311      =1  extern void EZUSB_Renum(void);
 312      =1  extern void EZUSB_Discon(BOOL renum);
 313      =1  
 314      =1  extern void EZUSB_Susp(void);
 315      =1  extern void EZUSB_Resume(void);
 316      =1  
 317      =1  extern void EZUSB_Delay1ms(void);
 318      =1  extern void EZUSB_Delay(WORD ms);
 319      =1  
 320      =1  extern CONFIGDSCR xdata*   EZUSB_GetConfigDscr(BYTE ConfigIdx);
 321      =1  extern INTRFCDSCR xdata*   EZUSB_GetIntrfcDscr(BYTE ConfigIdx, BYTE IntrfcIdx, BYTE AltSetting);
 322      =1  extern STRINGDSCR xdata*   EZUSB_GetStringDscr(BYTE StrIdx);
 323      =1  extern DSCR xdata*      EZUSB_GetDscr(BYTE index, DSCR* dscr, BYTE type);
 324      =1  
 325      =1  extern void EZUSB_InitI2C(void);
 326      =1  extern BOOL EZUSB_WriteI2C_(BYTE addr, BYTE length, BYTE xdata *dat);
 327      =1  extern BOOL EZUSB_ReadI2C_(BYTE addr, BYTE length, BYTE xdata *dat);
 328      =1  extern BOOL EZUSB_WriteI2C(BYTE addr, BYTE length, BYTE xdata *dat);
 329      =1  extern BOOL EZUSB_ReadI2C(BYTE addr, BYTE length, BYTE xdata *dat);
 330      =1  extern void EZUSB_WaitForEEPROMWrite(BYTE addr);
 331      =1  
 332      =1  extern void modify_endpoint_stall(BYTE epid, BYTE stall);
 333      =1  
 334      =1  #endif   // FX2_H
  16          #include "fx2regs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //   File:      FX2regs.h
   3      =1  //   Contents:   EZ-USB FX2/FX2LP/FX1 register declarations and bit mask definitions.
   4      =1  //
   5      =1  // $Archive: /USB/Target/Inc/fx2regs.h $
   6      =1  // $Date: 4/13/05 4:29p $
   7      =1  // $Revision: 42 $
   8      =1  //
   9      =1  //
  10      =1  //   Copyright (c) 2005 Cypress Semiconductor, All rights reserved
  11      =1  //-----------------------------------------------------------------------------
  12      =1  
  13      =1  #ifndef FX2REGS_H   /* Header Sentry */
  14      =1  #define FX2REGS_H
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 7   

  15      =1  
  16      =1  //-----------------------------------------------------------------------------
  17      =1  // FX2/FX2LP/FX1 Related Register Assignments
  18      =1  //-----------------------------------------------------------------------------
  19      =1  
  20      =1  // The Ez-USB FX2/FX2LP/FX1 registers are defined here. We use fx2regs.h for register 
  21      =1  // address allocation by using "#define ALLOCATE_EXTERN". 
  22      =1  // When using "#define ALLOCATE_EXTERN", you get (for instance): 
  23      =1  // xdata volatile BYTE OUT7BUF[64]   _at_   0x7B40;
  24      =1  // Such lines are created from FX2.h by using the preprocessor. 
  25      =1  // Incidently, these lines will not generate any space in the resulting hex 
  26      =1  // file; they just bind the symbols to the addresses for compilation. 
  27      =1  // You just need to put "#define ALLOCATE_EXTERN" in your main program file; 
  28      =1  // i.e. fw.c or a stand-alone C source file. 
  29      =1  // Without "#define ALLOCATE_EXTERN", you just get the external reference: 
  30      =1  // extern xdata volatile BYTE OUT7BUF[64]   ;//   0x7B40;
  31      =1  // This uses the concatenation operator "##" to insert a comment "//" 
  32      =1  // to cut off the end of the line, "_at_   0x7B40;", which is not wanted.
  33      =1  
  34      =1  #ifdef ALLOCATE_EXTERN
           =1 #define EXTERN
           =1 #define _AT_ _at_
           =1 #else
  38      =1  #define EXTERN extern
  39      =1  #define _AT_ ;/ ## /
  40      =1  #endif
  41      =1  
  42      =1  EXTERN xdata volatile BYTE GPIF_WAVE_DATA    _AT_ 0xE400;
  43      =1  EXTERN xdata volatile BYTE RES_WAVEDATA_END  _AT_ 0xE480;
  44      =1  
  45      =1  // General Configuration
  46      =1  
  47      =1  EXTERN xdata volatile BYTE CPUCS             _AT_ 0xE600;  // Control & Status
  48      =1  EXTERN xdata volatile BYTE IFCONFIG          _AT_ 0xE601;  // Interface Configuration
  49      =1  EXTERN xdata volatile BYTE PINFLAGSAB        _AT_ 0xE602;  // FIFO FLAGA and FLAGB Assignments
  50      =1  EXTERN xdata volatile BYTE PINFLAGSCD        _AT_ 0xE603;  // FIFO FLAGC and FLAGD Assignments
  51      =1  EXTERN xdata volatile BYTE FIFORESET         _AT_ 0xE604;  // Restore FIFOS to default state
  52      =1  EXTERN xdata volatile BYTE BREAKPT           _AT_ 0xE605;  // Breakpoint
  53      =1  EXTERN xdata volatile BYTE BPADDRH           _AT_ 0xE606;  // Breakpoint Address H
  54      =1  EXTERN xdata volatile BYTE BPADDRL           _AT_ 0xE607;  // Breakpoint Address L
  55      =1  EXTERN xdata volatile BYTE UART230           _AT_ 0xE608;  // 230 Kbaud clock for T0,T1,T2
  56      =1  EXTERN xdata volatile BYTE FIFOPINPOLAR      _AT_ 0xE609;  // FIFO polarities
  57      =1  EXTERN xdata volatile BYTE REVID             _AT_ 0xE60A;  // Chip Revision
  58      =1  EXTERN xdata volatile BYTE REVCTL            _AT_ 0xE60B;  // Chip Revision Control
  59      =1  
  60      =1  // Endpoint Configuration
  61      =1  
  62      =1  EXTERN xdata volatile BYTE EP1OUTCFG         _AT_ 0xE610;  // Endpoint 1-OUT Configuration
  63      =1  EXTERN xdata volatile BYTE EP1INCFG          _AT_ 0xE611;  // Endpoint 1-IN Configuration
  64      =1  EXTERN xdata volatile BYTE EP2CFG            _AT_ 0xE612;  // Endpoint 2 Configuration
  65      =1  EXTERN xdata volatile BYTE EP4CFG            _AT_ 0xE613;  // Endpoint 4 Configuration
  66      =1  EXTERN xdata volatile BYTE EP6CFG            _AT_ 0xE614;  // Endpoint 6 Configuration
  67      =1  EXTERN xdata volatile BYTE EP8CFG            _AT_ 0xE615;  // Endpoint 8 Configuration
  68      =1  EXTERN xdata volatile BYTE EP2FIFOCFG        _AT_ 0xE618;  // Endpoint 2 FIFO configuration
  69      =1  EXTERN xdata volatile BYTE EP4FIFOCFG        _AT_ 0xE619;  // Endpoint 4 FIFO configuration
  70      =1  EXTERN xdata volatile BYTE EP6FIFOCFG        _AT_ 0xE61A;  // Endpoint 6 FIFO configuration
  71      =1  EXTERN xdata volatile BYTE EP8FIFOCFG        _AT_ 0xE61B;  // Endpoint 8 FIFO configuration
  72      =1  EXTERN xdata volatile BYTE EP2AUTOINLENH     _AT_ 0xE620;  // Endpoint 2 Packet Length H (IN only)
  73      =1  EXTERN xdata volatile BYTE EP2AUTOINLENL     _AT_ 0xE621;  // Endpoint 2 Packet Length L (IN only)
  74      =1  EXTERN xdata volatile BYTE EP4AUTOINLENH     _AT_ 0xE622;  // Endpoint 4 Packet Length H (IN only)
  75      =1  EXTERN xdata volatile BYTE EP4AUTOINLENL     _AT_ 0xE623;  // Endpoint 4 Packet Length L (IN only)
  76      =1  EXTERN xdata volatile BYTE EP6AUTOINLENH     _AT_ 0xE624;  // Endpoint 6 Packet Length H (IN only)
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 8   

  77      =1  EXTERN xdata volatile BYTE EP6AUTOINLENL     _AT_ 0xE625;  // Endpoint 6 Packet Length L (IN only)
  78      =1  EXTERN xdata volatile BYTE EP8AUTOINLENH     _AT_ 0xE626;  // Endpoint 8 Packet Length H (IN only)
  79      =1  EXTERN xdata volatile BYTE EP8AUTOINLENL     _AT_ 0xE627;  // Endpoint 8 Packet Length L (IN only)
  80      =1  EXTERN xdata volatile BYTE EP2FIFOPFH        _AT_ 0xE630;  // EP2 Programmable Flag trigger H
  81      =1  EXTERN xdata volatile BYTE EP2FIFOPFL        _AT_ 0xE631;  // EP2 Programmable Flag trigger L
  82      =1  EXTERN xdata volatile BYTE EP4FIFOPFH        _AT_ 0xE632;  // EP4 Programmable Flag trigger H
  83      =1  EXTERN xdata volatile BYTE EP4FIFOPFL        _AT_ 0xE633;  // EP4 Programmable Flag trigger L
  84      =1  EXTERN xdata volatile BYTE EP6FIFOPFH        _AT_ 0xE634;  // EP6 Programmable Flag trigger H
  85      =1  EXTERN xdata volatile BYTE EP6FIFOPFL        _AT_ 0xE635;  // EP6 Programmable Flag trigger L
  86      =1  EXTERN xdata volatile BYTE EP8FIFOPFH        _AT_ 0xE636;  // EP8 Programmable Flag trigger H
  87      =1  EXTERN xdata volatile BYTE EP8FIFOPFL        _AT_ 0xE637;  // EP8 Programmable Flag trigger L
  88      =1  EXTERN xdata volatile BYTE EP2ISOINPKTS      _AT_ 0xE640;  // EP2 (if ISO) IN Packets per frame (1-3)
  89      =1  EXTERN xdata volatile BYTE EP4ISOINPKTS      _AT_ 0xE641;  // EP4 (if ISO) IN Packets per frame (1-3)
  90      =1  EXTERN xdata volatile BYTE EP6ISOINPKTS      _AT_ 0xE642;  // EP6 (if ISO) IN Packets per frame (1-3)
  91      =1  EXTERN xdata volatile BYTE EP8ISOINPKTS      _AT_ 0xE643;  // EP8 (if ISO) IN Packets per frame (1-3)
  92      =1  EXTERN xdata volatile BYTE INPKTEND          _AT_ 0xE648;  // Force IN Packet End
  93      =1  EXTERN xdata volatile BYTE OUTPKTEND         _AT_ 0xE649;  // Force OUT Packet End
  94      =1  
  95      =1  // Interrupts
  96      =1  
  97      =1  EXTERN xdata volatile BYTE EP2FIFOIE         _AT_ 0xE650;  // Endpoint 2 Flag Interrupt Enable
  98      =1  EXTERN xdata volatile BYTE EP2FIFOIRQ        _AT_ 0xE651;  // Endpoint 2 Flag Interrupt Request
  99      =1  EXTERN xdata volatile BYTE EP4FIFOIE         _AT_ 0xE652;  // Endpoint 4 Flag Interrupt Enable
 100      =1  EXTERN xdata volatile BYTE EP4FIFOIRQ        _AT_ 0xE653;  // Endpoint 4 Flag Interrupt Request
 101      =1  EXTERN xdata volatile BYTE EP6FIFOIE         _AT_ 0xE654;  // Endpoint 6 Flag Interrupt Enable
 102      =1  EXTERN xdata volatile BYTE EP6FIFOIRQ        _AT_ 0xE655;  // Endpoint 6 Flag Interrupt Request
 103      =1  EXTERN xdata volatile BYTE EP8FIFOIE         _AT_ 0xE656;  // Endpoint 8 Flag Interrupt Enable
 104      =1  EXTERN xdata volatile BYTE EP8FIFOIRQ        _AT_ 0xE657;  // Endpoint 8 Flag Interrupt Request
 105      =1  EXTERN xdata volatile BYTE IBNIE             _AT_ 0xE658;  // IN-BULK-NAK Interrupt Enable
 106      =1  EXTERN xdata volatile BYTE IBNIRQ            _AT_ 0xE659;  // IN-BULK-NAK interrupt Request
 107      =1  EXTERN xdata volatile BYTE NAKIE             _AT_ 0xE65A;  // Endpoint Ping NAK interrupt Enable
 108      =1  EXTERN xdata volatile BYTE NAKIRQ            _AT_ 0xE65B;  // Endpoint Ping NAK interrupt Request
 109      =1  EXTERN xdata volatile BYTE USBIE             _AT_ 0xE65C;  // USB Int Enables
 110      =1  EXTERN xdata volatile BYTE USBIRQ            _AT_ 0xE65D;  // USB Interrupt Requests
 111      =1  EXTERN xdata volatile BYTE EPIE              _AT_ 0xE65E;  // Endpoint Interrupt Enables
 112      =1  EXTERN xdata volatile BYTE EPIRQ             _AT_ 0xE65F;  // Endpoint Interrupt Requests
 113      =1  EXTERN xdata volatile BYTE GPIFIE            _AT_ 0xE660;  // GPIF Interrupt Enable
 114      =1  EXTERN xdata volatile BYTE GPIFIRQ           _AT_ 0xE661;  // GPIF Interrupt Request
 115      =1  EXTERN xdata volatile BYTE USBERRIE          _AT_ 0xE662;  // USB Error Interrupt Enables
 116      =1  EXTERN xdata volatile BYTE USBERRIRQ         _AT_ 0xE663;  // USB Error Interrupt Requests
 117      =1  EXTERN xdata volatile BYTE ERRCNTLIM         _AT_ 0xE664;  // USB Error counter and limit
 118      =1  EXTERN xdata volatile BYTE CLRERRCNT         _AT_ 0xE665;  // Clear Error Counter EC[3..0]
 119      =1  EXTERN xdata volatile BYTE INT2IVEC          _AT_ 0xE666;  // Interupt 2 (USB) Autovector
 120      =1  EXTERN xdata volatile BYTE INT4IVEC          _AT_ 0xE667;  // Interupt 4 (FIFOS & GPIF) Autovector
 121      =1  EXTERN xdata volatile BYTE INTSETUP          _AT_ 0xE668;  // Interrupt 2&4 Setup
 122      =1  
 123      =1  // Input/Output
 124      =1  
 125      =1  EXTERN xdata volatile BYTE PORTACFG          _AT_ 0xE670;  // I/O PORTA Alternate Configuration
 126      =1  EXTERN xdata volatile BYTE PORTCCFG          _AT_ 0xE671;  // I/O PORTC Alternate Configuration
 127      =1  EXTERN xdata volatile BYTE PORTECFG          _AT_ 0xE672;  // I/O PORTE Alternate Configuration
 128      =1  EXTERN xdata volatile BYTE I2CS              _AT_ 0xE678;  // Control & Status
 129      =1  EXTERN xdata volatile BYTE I2DAT             _AT_ 0xE679;  // Data
 130      =1  EXTERN xdata volatile BYTE I2CTL             _AT_ 0xE67A;  // I2C Control
 131      =1  EXTERN xdata volatile BYTE XAUTODAT1         _AT_ 0xE67B;  // Autoptr1 MOVX access
 132      =1  EXTERN xdata volatile BYTE XAUTODAT2         _AT_ 0xE67C;  // Autoptr2 MOVX access
 133      =1  
 134      =1  #define EXTAUTODAT1 XAUTODAT1
 135      =1  #define EXTAUTODAT2 XAUTODAT2
 136      =1  
 137      =1  // USB Control
 138      =1  
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 9   

 139      =1  EXTERN xdata volatile BYTE USBCS             _AT_ 0xE680;  // USB Control & Status
 140      =1  EXTERN xdata volatile BYTE SUSPEND           _AT_ 0xE681;  // Put chip into suspend
 141      =1  EXTERN xdata volatile BYTE WAKEUPCS          _AT_ 0xE682;  // Wakeup source and polarity
 142      =1  EXTERN xdata volatile BYTE TOGCTL            _AT_ 0xE683;  // Toggle Control
 143      =1  EXTERN xdata volatile BYTE USBFRAMEH         _AT_ 0xE684;  // USB Frame count H
 144      =1  EXTERN xdata volatile BYTE USBFRAMEL         _AT_ 0xE685;  // USB Frame count L
 145      =1  EXTERN xdata volatile BYTE MICROFRAME        _AT_ 0xE686;  // Microframe count, 0-7
 146      =1  EXTERN xdata volatile BYTE FNADDR            _AT_ 0xE687;  // USB Function address
 147      =1  
 148      =1  // Endpoints
 149      =1  
 150      =1  EXTERN xdata volatile BYTE EP0BCH            _AT_ 0xE68A;  // Endpoint 0 Byte Count H
 151      =1  EXTERN xdata volatile BYTE EP0BCL            _AT_ 0xE68B;  // Endpoint 0 Byte Count L
 152      =1  EXTERN xdata volatile BYTE EP1OUTBC          _AT_ 0xE68D;  // Endpoint 1 OUT Byte Count
 153      =1  EXTERN xdata volatile BYTE EP1INBC           _AT_ 0xE68F;  // Endpoint 1 IN Byte Count
 154      =1  EXTERN xdata volatile BYTE EP2BCH            _AT_ 0xE690;  // Endpoint 2 Byte Count H
 155      =1  EXTERN xdata volatile BYTE EP2BCL            _AT_ 0xE691;  // Endpoint 2 Byte Count L
 156      =1  EXTERN xdata volatile BYTE EP4BCH            _AT_ 0xE694;  // Endpoint 4 Byte Count H
 157      =1  EXTERN xdata volatile BYTE EP4BCL            _AT_ 0xE695;  // Endpoint 4 Byte Count L
 158      =1  EXTERN xdata volatile BYTE EP6BCH            _AT_ 0xE698;  // Endpoint 6 Byte Count H
 159      =1  EXTERN xdata volatile BYTE EP6BCL            _AT_ 0xE699;  // Endpoint 6 Byte Count L
 160      =1  EXTERN xdata volatile BYTE EP8BCH            _AT_ 0xE69C;  // Endpoint 8 Byte Count H
 161      =1  EXTERN xdata volatile BYTE EP8BCL            _AT_ 0xE69D;  // Endpoint 8 Byte Count L
 162      =1  EXTERN xdata volatile BYTE EP0CS             _AT_ 0xE6A0;  // Endpoint  Control and Status
 163      =1  EXTERN xdata volatile BYTE EP1OUTCS          _AT_ 0xE6A1;  // Endpoint 1 OUT Control and Status
 164      =1  EXTERN xdata volatile BYTE EP1INCS           _AT_ 0xE6A2;  // Endpoint 1 IN Control and Status
 165      =1  EXTERN xdata volatile BYTE EP2CS             _AT_ 0xE6A3;  // Endpoint 2 Control and Status
 166      =1  EXTERN xdata volatile BYTE EP4CS             _AT_ 0xE6A4;  // Endpoint 4 Control and Status
 167      =1  EXTERN xdata volatile BYTE EP6CS             _AT_ 0xE6A5;  // Endpoint 6 Control and Status
 168      =1  EXTERN xdata volatile BYTE EP8CS             _AT_ 0xE6A6;  // Endpoint 8 Control and Status
 169      =1  EXTERN xdata volatile BYTE EP2FIFOFLGS       _AT_ 0xE6A7;  // Endpoint 2 Flags
 170      =1  EXTERN xdata volatile BYTE EP4FIFOFLGS       _AT_ 0xE6A8;  // Endpoint 4 Flags
 171      =1  EXTERN xdata volatile BYTE EP6FIFOFLGS       _AT_ 0xE6A9;  // Endpoint 6 Flags
 172      =1  EXTERN xdata volatile BYTE EP8FIFOFLGS       _AT_ 0xE6AA;  // Endpoint 8 Flags
 173      =1  EXTERN xdata volatile BYTE EP2FIFOBCH        _AT_ 0xE6AB;  // EP2 FIFO total byte count H
 174      =1  EXTERN xdata volatile BYTE EP2FIFOBCL        _AT_ 0xE6AC;  // EP2 FIFO total byte count L
 175      =1  EXTERN xdata volatile BYTE EP4FIFOBCH        _AT_ 0xE6AD;  // EP4 FIFO total byte count H
 176      =1  EXTERN xdata volatile BYTE EP4FIFOBCL        _AT_ 0xE6AE;  // EP4 FIFO total byte count L
 177      =1  EXTERN xdata volatile BYTE EP6FIFOBCH        _AT_ 0xE6AF;  // EP6 FIFO total byte count H
 178      =1  EXTERN xdata volatile BYTE EP6FIFOBCL        _AT_ 0xE6B0;  // EP6 FIFO total byte count L
 179      =1  EXTERN xdata volatile BYTE EP8FIFOBCH        _AT_ 0xE6B1;  // EP8 FIFO total byte count H
 180      =1  EXTERN xdata volatile BYTE EP8FIFOBCL        _AT_ 0xE6B2;  // EP8 FIFO total byte count L
 181      =1  EXTERN xdata volatile BYTE SUDPTRH           _AT_ 0xE6B3;  // Setup Data Pointer high address byte
 182      =1  EXTERN xdata volatile BYTE SUDPTRL           _AT_ 0xE6B4;  // Setup Data Pointer low address byte
 183      =1  EXTERN xdata volatile BYTE SUDPTRCTL         _AT_ 0xE6B5;  // Setup Data Pointer Auto Mode
 184      =1  EXTERN xdata volatile BYTE SETUPDAT[8]       _AT_ 0xE6B8;  // 8 bytes of SETUP data
 185      =1  
 186      =1  // GPIF
 187      =1  
 188      =1  EXTERN xdata volatile BYTE GPIFWFSELECT      _AT_ 0xE6C0;  // Waveform Selector
 189      =1  EXTERN xdata volatile BYTE GPIFIDLECS        _AT_ 0xE6C1;  // GPIF Done, GPIF IDLE drive mode
 190      =1  EXTERN xdata volatile BYTE GPIFIDLECTL       _AT_ 0xE6C2;  // Inactive Bus, CTL states
 191      =1  EXTERN xdata volatile BYTE GPIFCTLCFG        _AT_ 0xE6C3;  // CTL OUT pin drive
 192      =1  EXTERN xdata volatile BYTE GPIFADRH          _AT_ 0xE6C4;  // GPIF Address H
 193      =1  EXTERN xdata volatile BYTE GPIFADRL          _AT_ 0xE6C5;  // GPIF Address L
 194      =1  
 195      =1  EXTERN xdata volatile BYTE GPIFTCB3          _AT_ 0xE6CE;  // GPIF Transaction Count Byte 3
 196      =1  EXTERN xdata volatile BYTE GPIFTCB2          _AT_ 0xE6CF;  // GPIF Transaction Count Byte 2
 197      =1  EXTERN xdata volatile BYTE GPIFTCB1          _AT_ 0xE6D0;  // GPIF Transaction Count Byte 1
 198      =1  EXTERN xdata volatile BYTE GPIFTCB0          _AT_ 0xE6D1;  // GPIF Transaction Count Byte 0
 199      =1  
 200      =1  #define EP2GPIFTCH GPIFTCB1   // these are here for backwards compatibility
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 10  

 201      =1  #define EP2GPIFTCL GPIFTCB0   // 
 202      =1  #define EP4GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 203      =1  #define EP4GPIFTCL GPIFTCB0   // 
 204      =1  #define EP6GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 205      =1  #define EP6GPIFTCL GPIFTCB0   // 
 206      =1  #define EP8GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 207      =1  #define EP8GPIFTCL GPIFTCB0   // 
 208      =1  
 209      =1  EXTERN xdata volatile BYTE EP2GPIFFLGSEL     _AT_ 0xE6D2;  // EP2 GPIF Flag select
 210      =1  EXTERN xdata volatile BYTE EP2GPIFPFSTOP     _AT_ 0xE6D3;  // Stop GPIF EP2 transaction on prog. flag
 211      =1  EXTERN xdata volatile BYTE EP2GPIFTRIG       _AT_ 0xE6D4;  // EP2 FIFO Trigger
 212      =1  EXTERN xdata volatile BYTE EP4GPIFFLGSEL     _AT_ 0xE6DA;  // EP4 GPIF Flag select
 213      =1  EXTERN xdata volatile BYTE EP4GPIFPFSTOP     _AT_ 0xE6DB;  // Stop GPIF EP4 transaction on prog. flag
 214      =1  EXTERN xdata volatile BYTE EP4GPIFTRIG       _AT_ 0xE6DC;  // EP4 FIFO Trigger
 215      =1  EXTERN xdata volatile BYTE EP6GPIFFLGSEL     _AT_ 0xE6E2;  // EP6 GPIF Flag select
 216      =1  EXTERN xdata volatile BYTE EP6GPIFPFSTOP     _AT_ 0xE6E3;  // Stop GPIF EP6 transaction on prog. flag
 217      =1  EXTERN xdata volatile BYTE EP6GPIFTRIG       _AT_ 0xE6E4;  // EP6 FIFO Trigger
 218      =1  EXTERN xdata volatile BYTE EP8GPIFFLGSEL     _AT_ 0xE6EA;  // EP8 GPIF Flag select
 219      =1  EXTERN xdata volatile BYTE EP8GPIFPFSTOP     _AT_ 0xE6EB;  // Stop GPIF EP8 transaction on prog. flag
 220      =1  EXTERN xdata volatile BYTE EP8GPIFTRIG       _AT_ 0xE6EC;  // EP8 FIFO Trigger
 221      =1  EXTERN xdata volatile BYTE XGPIFSGLDATH      _AT_ 0xE6F0;  // GPIF Data H (16-bit mode only)
 222      =1  EXTERN xdata volatile BYTE XGPIFSGLDATLX     _AT_ 0xE6F1;  // Read/Write GPIF Data L & trigger transac
 223      =1  EXTERN xdata volatile BYTE XGPIFSGLDATLNOX   _AT_ 0xE6F2;  // Read GPIF Data L, no transac trigger
 224      =1  EXTERN xdata volatile BYTE GPIFREADYCFG      _AT_ 0xE6F3;  // Internal RDY,Sync/Async, RDY5CFG
 225      =1  EXTERN xdata volatile BYTE GPIFREADYSTAT     _AT_ 0xE6F4;  // RDY pin states
 226      =1  EXTERN xdata volatile BYTE GPIFABORT         _AT_ 0xE6F5;  // Abort GPIF cycles
 227      =1  
 228      =1  // UDMA
 229      =1  
 230      =1  EXTERN xdata volatile BYTE FLOWSTATE         _AT_  0xE6C6; //Defines GPIF flow state
 231      =1  EXTERN xdata volatile BYTE FLOWLOGIC         _AT_  0xE6C7; //Defines flow/hold decision criteria
 232      =1  EXTERN xdata volatile BYTE FLOWEQ0CTL        _AT_  0xE6C8; //CTL states during active flow state
 233      =1  EXTERN xdata volatile BYTE FLOWEQ1CTL        _AT_  0xE6C9; //CTL states during hold flow state
 234      =1  EXTERN xdata volatile BYTE FLOWHOLDOFF       _AT_  0xE6CA;
 235      =1  EXTERN xdata volatile BYTE FLOWSTB           _AT_  0xE6CB; //CTL/RDY Signal to use as master data strobe 
 236      =1  EXTERN xdata volatile BYTE FLOWSTBEDGE       _AT_  0xE6CC; //Defines active master strobe edge
 237      =1  EXTERN xdata volatile BYTE FLOWSTBHPERIOD    _AT_  0xE6CD; //Half Period of output master strobe
 238      =1  EXTERN xdata volatile BYTE GPIFHOLDAMOUNT    _AT_  0xE60C; //Data delay shift 
 239      =1  EXTERN xdata volatile BYTE UDMACRCH          _AT_  0xE67D; //CRC Upper byte
 240      =1  EXTERN xdata volatile BYTE UDMACRCL          _AT_  0xE67E; //CRC Lower byte
 241      =1  EXTERN xdata volatile BYTE UDMACRCQUAL       _AT_  0xE67F; //UDMA In only, host terminated use only
 242      =1  
 243      =1  
 244      =1  // Debug/Test
 245      =1  // The following registers are for Cypress's internal testing purposes only.
 246      =1  // These registers are not documented in the datasheet or the Technical Reference
 247      =1  // Manual as they were not designed for end user application usage 
 248      =1  EXTERN xdata volatile BYTE DBUG              _AT_ 0xE6F8;  // Debug
 249      =1  EXTERN xdata volatile BYTE TESTCFG           _AT_ 0xE6F9;  // Test configuration
 250      =1  EXTERN xdata volatile BYTE USBTEST           _AT_ 0xE6FA;  // USB Test Modes
 251      =1  EXTERN xdata volatile BYTE CT1               _AT_ 0xE6FB;  // Chirp Test--Override
 252      =1  EXTERN xdata volatile BYTE CT2               _AT_ 0xE6FC;  // Chirp Test--FSM
 253      =1  EXTERN xdata volatile BYTE CT3               _AT_ 0xE6FD;  // Chirp Test--Control Signals
 254      =1  EXTERN xdata volatile BYTE CT4               _AT_ 0xE6FE;  // Chirp Test--Inputs
 255      =1  
 256      =1  // Endpoint Buffers
 257      =1  
 258      =1  EXTERN xdata volatile BYTE EP0BUF[64]        _AT_ 0xE740;  // EP0 IN-OUT buffer
 259      =1  EXTERN xdata volatile BYTE EP1OUTBUF[64]     _AT_ 0xE780;  // EP1-OUT buffer
 260      =1  EXTERN xdata volatile BYTE EP1INBUF[64]      _AT_ 0xE7C0;  // EP1-IN buffer
 261      =1  EXTERN xdata volatile BYTE EP2FIFOBUF[1024]  _AT_ 0xF000;  // 512/1024-byte EP2 buffer (IN or OUT)
 262      =1  EXTERN xdata volatile BYTE EP4FIFOBUF[1024]  _AT_ 0xF400;  // 512 byte EP4 buffer (IN or OUT)
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 11  

 263      =1  EXTERN xdata volatile BYTE EP6FIFOBUF[1024]  _AT_ 0xF800;  // 512/1024-byte EP6 buffer (IN or OUT)
 264      =1  EXTERN xdata volatile BYTE EP8FIFOBUF[1024]  _AT_ 0xFC00;  // 512 byte EP8 buffer (IN or OUT)
 265      =1  
 266      =1  // Error Correction Code (ECC) Registers (FX2LP/FX1 only)
 267      =1  
 268      =1  EXTERN xdata volatile BYTE ECCCFG            _AT_ 0xE628;  // ECC Configuration
 269      =1  EXTERN xdata volatile BYTE ECCRESET          _AT_ 0xE629;  // ECC Reset
 270      =1  EXTERN xdata volatile BYTE ECC1B0            _AT_ 0xE62A;  // ECC1 Byte 0
 271      =1  EXTERN xdata volatile BYTE ECC1B1            _AT_ 0xE62B;  // ECC1 Byte 1
 272      =1  EXTERN xdata volatile BYTE ECC1B2            _AT_ 0xE62C;  // ECC1 Byte 2
 273      =1  EXTERN xdata volatile BYTE ECC2B0            _AT_ 0xE62D;  // ECC2 Byte 0
 274      =1  EXTERN xdata volatile BYTE ECC2B1            _AT_ 0xE62E;  // ECC2 Byte 1
 275      =1  EXTERN xdata volatile BYTE ECC2B2            _AT_ 0xE62F;  // ECC2 Byte 2
 276      =1  
 277      =1  // Feature Registers  (FX2LP/FX1 only)
 278      =1  EXTERN xdata volatile BYTE GPCR2             _AT_ 0xE50D;  // Chip Features
 279      =1  
 280      =1  #undef EXTERN
 281      =1  #undef _AT_
 282      =1  
 283      =1  /*-----------------------------------------------------------------------------
 284      =1     Special Function Registers (SFRs)
 285      =1     The byte registers and bits defined in the following list are based
 286      =1     on the Synopsis definition of the 8051 Special Function Registers for EZ-USB. 
 287      =1      If you modify the register definitions below, please regenerate the file 
 288      =1      "ezregs.inc" which includes the same basic information for assembly inclusion.
 289      =1  -----------------------------------------------------------------------------*/
 290      =1  
 291      =1  sfr IOA     = 0x80;
 292      =1           /*  IOA  */
 293      =1           sbit PA0    = 0x80 + 0;
 294      =1           sbit PA1    = 0x80 + 1;
 295      =1           sbit PA2    = 0x80 + 2;
 296      =1           sbit PA3    = 0x80 + 3;
 297      =1  
 298      =1           sbit PA4    = 0x80 + 4;
 299      =1           sbit PA5    = 0x80 + 5;
 300      =1           sbit PA6    = 0x80 + 6;
 301      =1           sbit PA7    = 0x80 + 7;
 302      =1  sfr SP      = 0x81;
 303      =1  sfr DPL     = 0x82;
 304      =1  sfr DPH     = 0x83;
 305      =1  sfr DPL1    = 0x84;
 306      =1  sfr DPH1    = 0x85;
 307      =1  sfr DPS     = 0x86;
 308      =1           /*  DPS  */
 309      =1           // sbit SEL   = 0x86+0;
 310      =1  sfr PCON    = 0x87;
 311      =1           /*  PCON  */
 312      =1           //sbit IDLE   = 0x87+0;
 313      =1           //sbit STOP   = 0x87+1;
 314      =1           //sbit GF0    = 0x87+2;
 315      =1           //sbit GF1    = 0x87+3;
 316      =1           //sbit SMOD0  = 0x87+7;
 317      =1  sfr TCON    = 0x88;
 318      =1           /*  TCON  */
 319      =1           sbit IT0    = 0x88+0;
 320      =1           sbit IE0    = 0x88+1;
 321      =1           sbit IT1    = 0x88+2;
 322      =1           sbit IE1    = 0x88+3;
 323      =1           sbit TR0    = 0x88+4;
 324      =1           sbit TF0    = 0x88+5;
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 12  

 325      =1           sbit TR1    = 0x88+6;
 326      =1           sbit TF1    = 0x88+7;
 327      =1  sfr TMOD    = 0x89;
 328      =1           /*  TMOD  */
 329      =1           //sbit M00    = 0x89+0;
 330      =1           //sbit M10    = 0x89+1;
 331      =1           //sbit CT0    = 0x89+2;
 332      =1           //sbit GATE0  = 0x89+3;
 333      =1           //sbit M01    = 0x89+4;
 334      =1           //sbit M11    = 0x89+5;
 335      =1           //sbit CT1    = 0x89+6;
 336      =1           //sbit GATE1  = 0x89+7;
 337      =1  sfr TL0     = 0x8A;
 338      =1  sfr TL1     = 0x8B;
 339      =1  sfr TH0     = 0x8C;
 340      =1  sfr TH1     = 0x8D;
 341      =1  sfr CKCON   = 0x8E;
 342      =1           /*  CKCON  */
 343      =1           //sbit MD0    = 0x89+0;
 344      =1           //sbit MD1    = 0x89+1;
 345      =1           //sbit MD2    = 0x89+2;
 346      =1           //sbit T0M    = 0x89+3;
 347      =1           //sbit T1M    = 0x89+4;
 348      =1           //sbit T2M    = 0x89+5;
 349      =1  sfr SPC_FNC = 0x8F; // Was WRS in Reg320
 350      =1           /*  CKCON  */
 351      =1           //sbit WRS    = 0x8F+0;
 352      =1  sfr IOB     = 0x90;
 353      =1           /*  IOB  */
 354      =1           sbit PB0    = 0x90 + 0;
 355      =1           sbit PB1    = 0x90 + 1;
 356      =1           sbit PB2    = 0x90 + 2;
 357      =1           sbit PB3    = 0x90 + 3;
 358      =1  
 359      =1           sbit PB4    = 0x90 + 4;
 360      =1           sbit PB5    = 0x90 + 5;
 361      =1           sbit PB6    = 0x90 + 6;
 362      =1           sbit PB7    = 0x90 + 7;
 363      =1  sfr EXIF    = 0x91; // EXIF Bit Values differ from Reg320
 364      =1           /*  EXIF  */
 365      =1           //sbit USBINT = 0x91+4;
 366      =1           //sbit I2CINT = 0x91+5;
 367      =1           //sbit IE4    = 0x91+6;
 368      =1           //sbit IE5    = 0x91+7;
 369      =1  sfr MPAGE  = 0x92;
 370      =1  sfr SCON0  = 0x98;
 371      =1           /*  SCON0  */
 372      =1           sbit RI    = 0x98+0;
 373      =1           sbit TI    = 0x98+1;
 374      =1           sbit RB8   = 0x98+2;
 375      =1           sbit TB8   = 0x98+3;
 376      =1           sbit REN   = 0x98+4;
 377      =1           sbit SM2   = 0x98+5;
 378      =1           sbit SM1   = 0x98+6;
 379      =1           sbit SM0   = 0x98+7;
 380      =1  sfr SBUF0  = 0x99;
 381      =1  
 382      =1  #define AUTOPTR1H AUTOPTRH1 // for backwards compatibility with examples
 383      =1  #define AUTOPTR1L AUTOPTRL1 // for backwards compatibility with examples
 384      =1  #define APTR1H AUTOPTRH1 // for backwards compatibility with examples
 385      =1  #define APTR1L AUTOPTRL1 // for backwards compatibility with examples
 386      =1  
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 13  

 387      =1  // this is how they are defined in the TRM
 388      =1  sfr AUTOPTRH1     = 0x9A; 
 389      =1  sfr AUTOPTRL1     = 0x9B; 
 390      =1  sfr AUTOPTRH2     = 0x9D;
 391      =1  sfr AUTOPTRL2     = 0x9E; 
 392      =1  
 393      =1  sfr IOC        = 0xA0;
 394      =1           /*  IOC  */
 395      =1           sbit PC0    = 0xA0 + 0;
 396      =1           sbit PC1    = 0xA0 + 1;
 397      =1           sbit PC2    = 0xA0 + 2;
 398      =1           sbit PC3    = 0xA0 + 3;
 399      =1  
 400      =1           sbit PC4    = 0xA0 + 4;
 401      =1           sbit PC5    = 0xA0 + 5;
 402      =1           sbit PC6    = 0xA0 + 6;
 403      =1           sbit PC7    = 0xA0 + 7;
 404      =1  sfr INT2CLR    = 0xA1;
 405      =1  sfr INT4CLR    = 0xA2;
 406      =1  
 407      =1  sfr IE     = 0xA8;
 408      =1           /*  IE  */
 409      =1           sbit EX0   = 0xA8+0;
 410      =1           sbit ET0   = 0xA8+1;
 411      =1           sbit EX1   = 0xA8+2;
 412      =1           sbit ET1   = 0xA8+3;
 413      =1           sbit ES0   = 0xA8+4;
 414      =1           sbit ET2   = 0xA8+5;
 415      =1           sbit ES1   = 0xA8+6;
 416      =1           sbit EA    = 0xA8+7;
 417      =1  
 418      =1  sfr EP2468STAT     = 0xAA;
 419      =1           /* EP2468STAT */
 420      =1           //sbit EP2E   = 0xAA+0;
 421      =1           //sbit EP2F   = 0xAA+1;
 422      =1           //sbit EP4E   = 0xAA+2;
 423      =1           //sbit EP4F   = 0xAA+3;
 424      =1           //sbit EP6E   = 0xAA+4;
 425      =1           //sbit EP6F   = 0xAA+5;
 426      =1           //sbit EP8E   = 0xAA+6;
 427      =1           //sbit EP8F   = 0xAA+7;
 428      =1  
 429      =1  sfr EP24FIFOFLGS   = 0xAB;
 430      =1  sfr EP68FIFOFLGS   = 0xAC;
 431      =1  sfr AUTOPTRSETUP  = 0xAF;
 432      =1           /* AUTOPTRSETUP */
 433      =1           //   sbit EXTACC  = 0xAF+0;
 434      =1           //   sbit APTR1FZ = 0xAF+1;
 435      =1           //   sbit APTR2FZ = 0xAF+2;
 436      =1  
 437      =1  sfr IOD     = 0xB0;
 438      =1           /*  IOD  */
 439      =1           sbit PD0    = 0xB0 + 0;
 440      =1           sbit PD1    = 0xB0 + 1;
 441      =1           sbit PD2    = 0xB0 + 2;
 442      =1           sbit PD3    = 0xB0 + 3;
 443      =1  
 444      =1           sbit PD4    = 0xB0 + 4;
 445      =1           sbit PD5    = 0xB0 + 5;
 446      =1           sbit PD6    = 0xB0 + 6;
 447      =1           sbit PD7    = 0xB0 + 7;
 448      =1  sfr IOE     = 0xB1;
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 14  

 449      =1  sfr OEA     = 0xB2;
 450      =1  sfr OEB     = 0xB3;
 451      =1  sfr OEC     = 0xB4;
 452      =1  sfr OED     = 0xB5;
 453      =1  sfr OEE     = 0xB6;
 454      =1  
 455      =1  sfr IP     = 0xB8;
 456      =1           /*  IP  */
 457      =1           sbit PX0   = 0xB8+0;
 458      =1           sbit PT0   = 0xB8+1;
 459      =1           sbit PX1   = 0xB8+2;
 460      =1           sbit PT1   = 0xB8+3;
 461      =1           sbit PS0   = 0xB8+4;
 462      =1           sbit PT2   = 0xB8+5;
 463      =1           sbit PS1   = 0xB8+6;
 464      =1  
 465      =1  sfr EP01STAT    = 0xBA;
 466      =1  sfr GPIFTRIG    = 0xBB;
 467      =1                  
 468      =1  sfr GPIFSGLDATH     = 0xBD;
 469      =1  sfr GPIFSGLDATLX    = 0xBE;
 470      =1  sfr GPIFSGLDATLNOX  = 0xBF;
 471      =1  
 472      =1  sfr SCON1  = 0xC0;
 473      =1           /*  SCON1  */
 474      =1           sbit RI1   = 0xC0+0;
 475      =1           sbit TI1   = 0xC0+1;
 476      =1           sbit RB81  = 0xC0+2;
 477      =1           sbit TB81  = 0xC0+3;
 478      =1           sbit REN1  = 0xC0+4;
 479      =1           sbit SM21  = 0xC0+5;
 480      =1           sbit SM11  = 0xC0+6;
 481      =1           sbit SM01  = 0xC0+7;
 482      =1  sfr SBUF1  = 0xC1;
 483      =1  sfr T2CON  = 0xC8;
 484      =1           /*  T2CON  */
 485      =1           sbit CP_RL2 = 0xC8+0;
 486      =1           sbit C_T2  = 0xC8+1;
 487      =1           sbit TR2   = 0xC8+2;
 488      =1           sbit EXEN2 = 0xC8+3;
 489      =1           sbit TCLK  = 0xC8+4;
 490      =1           sbit RCLK  = 0xC8+5;
 491      =1           sbit EXF2  = 0xC8+6;
 492      =1           sbit TF2   = 0xC8+7;
 493      =1  sfr RCAP2L = 0xCA;
 494      =1  sfr RCAP2H = 0xCB;
 495      =1  sfr TL2    = 0xCC;
 496      =1  sfr TH2    = 0xCD;
 497      =1  sfr PSW    = 0xD0;
 498      =1           /*  PSW  */
 499      =1           sbit P     = 0xD0+0;
 500      =1           sbit FL    = 0xD0+1;
 501      =1           sbit OV    = 0xD0+2;
 502      =1           sbit RS0   = 0xD0+3;
 503      =1           sbit RS1   = 0xD0+4;
 504      =1           sbit F0    = 0xD0+5;
 505      =1           sbit AC    = 0xD0+6;
 506      =1           sbit CY    = 0xD0+7;
 507      =1  sfr EICON  = 0xD8; // Was WDCON in DS80C320; Bit Values differ from Reg320
 508      =1           /*  EICON  */
 509      =1           sbit INT6  = 0xD8+3;
 510      =1           sbit RESI  = 0xD8+4;
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 15  

 511      =1           sbit ERESI = 0xD8+5;
 512      =1           sbit SMOD1 = 0xD8+7;
 513      =1  sfr ACC    = 0xE0;
 514      =1  sfr EIE    = 0xE8; // EIE Bit Values differ from Reg320
 515      =1           /*  EIE  */
 516      =1           sbit EUSB    = 0xE8+0;
 517      =1           sbit EI2C    = 0xE8+1;
 518      =1           sbit EIEX4   = 0xE8+2;
 519      =1           sbit EIEX5   = 0xE8+3;
 520      =1           sbit EIEX6   = 0xE8+4;
 521      =1  sfr B      = 0xF0;
 522      =1  sfr EIP    = 0xF8; // EIP Bit Values differ from Reg320
 523      =1           /*  EIP  */
 524      =1           sbit PUSB    = 0xF8+0;
 525      =1           sbit PI2C    = 0xF8+1;
 526      =1           sbit EIPX4   = 0xF8+2;
 527      =1           sbit EIPX5   = 0xF8+3;
 528      =1           sbit EIPX6   = 0xF8+4;
 529      =1  
 530      =1  /*-----------------------------------------------------------------------------
 531      =1     Bit Masks
 532      =1  -----------------------------------------------------------------------------*/
 533      =1  
 534      =1  /* CPU Control & Status Register (CPUCS) */
 535      =1  #define bmPRTCSTB    bmBIT5
 536      =1  #define bmCLKSPD     (bmBIT4 | bmBIT3)
 537      =1  #define bmCLKSPD1    bmBIT4
 538      =1  #define bmCLKSPD0    bmBIT3
 539      =1  #define bmCLKINV     bmBIT2
 540      =1  #define bmCLKOE      bmBIT1
 541      =1  #define bm8051RES    bmBIT0
 542      =1  /* Port Alternate Configuration Registers */
 543      =1  /* Port A (PORTACFG) */
 544      =1  #define bmFLAGD      bmBIT7
 545      =1  #define bmINT1       bmBIT1
 546      =1  #define bmINT0       bmBIT0
 547      =1  /* Port C (PORTCCFG) */
 548      =1  #define bmGPIFA7     bmBIT7
 549      =1  #define bmGPIFA6     bmBIT6
 550      =1  #define bmGPIFA5     bmBIT5
 551      =1  #define bmGPIFA4     bmBIT4
 552      =1  #define bmGPIFA3     bmBIT3
 553      =1  #define bmGPIFA2     bmBIT2
 554      =1  #define bmGPIFA1     bmBIT1
 555      =1  #define bmGPIFA0     bmBIT0
 556      =1  /* Port E (PORTECFG) */
 557      =1  #define bmGPIFA8     bmBIT7
 558      =1  #define bmT2EX       bmBIT6
 559      =1  #define bmINT6       bmBIT5
 560      =1  #define bmRXD1OUT    bmBIT4
 561      =1  #define bmRXD0OUT    bmBIT3
 562      =1  #define bmT2OUT      bmBIT2
 563      =1  #define bmT1OUT      bmBIT1
 564      =1  #define bmT0OUT      bmBIT0
 565      =1  
 566      =1  /* I2C Control & Status Register (I2CS) */
 567      =1  #define bmSTART      bmBIT7
 568      =1  #define bmSTOP       bmBIT6
 569      =1  #define bmLASTRD     bmBIT5
 570      =1  #define bmID         (bmBIT4 | bmBIT3)
 571      =1  #define bmBERR       bmBIT2
 572      =1  #define bmACK        bmBIT1
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 16  

 573      =1  #define bmDONE       bmBIT0
 574      =1  /* I2C Control Register (I2CTL) */
 575      =1  #define bmSTOPIE     bmBIT1
 576      =1  #define bm400KHZ     bmBIT0
 577      =1  /* Interrupt 2 (USB) Autovector Register (INT2IVEC) */
 578      =1  #define bmIV4        bmBIT6
 579      =1  #define bmIV3        bmBIT5
 580      =1  #define bmIV2        bmBIT4
 581      =1  #define bmIV1        bmBIT3
 582      =1  #define bmIV0        bmBIT2
 583      =1  /* USB Interrupt Request & Enable Registers (USBIE/USBIRQ) */
 584      =1  #define bmEP0ACK     bmBIT6
 585      =1  #define bmHSGRANT    bmBIT5
 586      =1  #define bmURES       bmBIT4
 587      =1  #define bmSUSP       bmBIT3
 588      =1  #define bmSUTOK      bmBIT2
 589      =1  #define bmSOF        bmBIT1
 590      =1  #define bmSUDAV      bmBIT0
 591      =1  /* Breakpoint register (BREAKPT) */
 592      =1  #define bmBREAK      bmBIT3
 593      =1  #define bmBPPULSE    bmBIT2
 594      =1  #define bmBPEN       bmBIT1
 595      =1  /* Interrupt 2 & 4 Setup (INTSETUP) */
 596      =1  #define bmAV2EN      bmBIT3
 597      =1  #define INT4IN       bmBIT1
 598      =1  #define bmAV4EN      bmBIT0
 599      =1  /* USB Control & Status Register (USBCS) */
 600      =1  #define bmHSM        bmBIT7
 601      =1  #define bmDISCON     bmBIT3
 602      =1  #define bmNOSYNSOF   bmBIT2
 603      =1  #define bmRENUM      bmBIT1
 604      =1  #define bmSIGRESUME  bmBIT0
 605      =1  /* Wakeup Control and Status Register (WAKEUPCS) */
 606      =1  #define bmWU2        bmBIT7
 607      =1  #define bmWU         bmBIT6
 608      =1  #define bmWU2POL     bmBIT5
 609      =1  #define bmWUPOL      bmBIT4
 610      =1  #define bmDPEN       bmBIT2
 611      =1  #define bmWU2EN      bmBIT1
 612      =1  #define bmWUEN       bmBIT0
 613      =1  /* End Point 0 Control & Status Register (EP0CS) */
 614      =1  #define bmHSNAK      bmBIT7
 615      =1  /* End Point 0-1 Control & Status Registers (EP0CS/EP1OUTCS/EP1INCS) */
 616      =1  #define bmEPBUSY     bmBIT1
 617      =1  #define bmEPSTALL    bmBIT0
 618      =1  /* End Point 2-8 Control & Status Registers (EP2CS/EP4CS/EP6CS/EP8CS) */
 619      =1  #define bmNPAK       (bmBIT6 | bmBIT5 | bmBIT4)
 620      =1  #define bmEPFULL     bmBIT3
 621      =1  #define bmEPEMPTY    bmBIT2
 622      =1  /* Endpoint Status (EP2468STAT) SFR bits */
 623      =1  #define bmEP8FULL    bmBIT7
 624      =1  #define bmEP8EMPTY   bmBIT6
 625      =1  #define bmEP6FULL    bmBIT5
 626      =1  #define bmEP6EMPTY   bmBIT4
 627      =1  #define bmEP4FULL    bmBIT3
 628      =1  #define bmEP4EMPTY   bmBIT2
 629      =1  #define bmEP2FULL    bmBIT1
 630      =1  #define bmEP2EMPTY   bmBIT0
 631      =1  /* SETUP Data Pointer Auto Mode (SUDPTRCTL) */
 632      =1  #define bmSDPAUTO    bmBIT0
 633      =1  /* Endpoint Data Toggle Control (TOGCTL) */
 634      =1  #define bmQUERYTOGGLE  bmBIT7
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 17  

 635      =1  #define bmSETTOGGLE    bmBIT6
 636      =1  #define bmRESETTOGGLE  bmBIT5
 637      =1  #define bmTOGCTLEPMASK bmBIT3 | bmBIT2 | bmBIT1 | bmBIT0
 638      =1  /* IBN (In Bulk Nak) enable and request bits (IBNIE/IBNIRQ) */
 639      =1  #define bmEP8IBN     bmBIT5
 640      =1  #define bmEP6IBN     bmBIT4
 641      =1  #define bmEP4IBN     bmBIT3
 642      =1  #define bmEP2IBN     bmBIT2
 643      =1  #define bmEP1IBN     bmBIT1
 644      =1  #define bmEP0IBN     bmBIT0
 645      =1  
 646      =1  /* PING-NAK enable and request bits (NAKIE/NAKIRQ) */
 647      =1  #define bmEP8PING     bmBIT7
 648      =1  #define bmEP6PING     bmBIT6
 649      =1  #define bmEP4PING     bmBIT5
 650      =1  #define bmEP2PING     bmBIT4
 651      =1  #define bmEP1PING     bmBIT3
 652      =1  #define bmEP0PING     bmBIT2
 653      =1  #define bmIBN         bmBIT0
 654      =1  
 655      =1  /* Interface Configuration bits (IFCONFIG) */
 656      =1  #define bmIFCLKSRC    bmBIT7
 657      =1  #define bm3048MHZ     bmBIT6
 658      =1  #define bmIFCLKOE     bmBIT5
 659      =1  #define bmIFCLKPOL    bmBIT4
 660      =1  #define bmASYNC       bmBIT3
 661      =1  #define bmGSTATE      bmBIT2
 662      =1  #define bmIFCFG1      bmBIT1
 663      =1  #define bmIFCFG0      bmBIT0
 664      =1  #define bmIFCFGMASK   (bmIFCFG0 | bmIFCFG1)
 665      =1  #define bmIFGPIF      bmIFCFG1
 666      =1  
 667      =1  /* EP 2468 FIFO Configuration bits (EP2FIFOCFG,EP4FIFOCFG,EP6FIFOCFG,EP8FIFOCFG) */
 668      =1  #define bmINFM       bmBIT6
 669      =1  #define bmOEP        bmBIT5
 670      =1  #define bmAUTOOUT    bmBIT4
 671      =1  #define bmAUTOIN     bmBIT3
 672      =1  #define bmZEROLENIN  bmBIT2
 673      =1  #define bmWORDWIDE   bmBIT0
 674      =1  
 675      =1  /* Chip Revision Control Bits (REVCTL) - used to ebable/disable revision specidic
 676      =1     features */ 
 677      =1  #define bmNOAUTOARM    bmBIT1
 678      =1  #define bmSKIPCOMMIT   bmBIT0
 679      =1  
 680      =1  /* Fifo Reset bits (FIFORESET) */
 681      =1  #define bmNAKALL       bmBIT7
 682      =1  
 683      =1  /* Chip Feature Register (GPCR2) */
 684      =1  #define bmFULLSPEEDONLY    bmBIT4
 685      =1  
 686      =1  #endif   /* FX2REGS_H */
  17          #include "syncdly.h"            // SYNCDELAY macro
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //   File:      syncdly.h
   3      =1  //   Contents:  EZ-USB FX2 Synchronization Delay (SYNCDELAY) Macro
   4      =1  //               Enter with _IFREQ = IFCLK in kHz
   5      =1  //               Enter with _CFREQ = CLKOUT in kHz
   6      =1  //
   7      =1  // $Archive: /USB/Target/Inc/syncdly.h $
   8      =1  // $Date: 8/12/03 4:26p $
   9      =1  // $Revision: 2 $
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 18  

  10      =1  //
  11      =1  //
  12      =1  //-----------------------------------------------------------------------------
  13      =1  // Copyright 2003, Cypress Semiconductor Corporation
  14      =1  //
  15      =1  // This software is owned by Cypress Semiconductor Corporation (Cypress) and is
  16      =1  // protected by United States copyright laws and international treaty provisions. Cypress
  17      =1  // hereby grants to Licensee a personal, non-exclusive, non-transferable license to copy,
  18      =1  // use, modify, create derivative works of, and compile the Cypress Source Code and
  19      =1  // derivative works for the sole purpose of creating custom software in support of Licensee
  20      =1  // product ("Licensee Product") to be used only in conjunction with a Cypress integrated
  21      =1  // circuit. Any reproduction, modification, translation, compilation, or representation of this
  22      =1  // software except as specified above is prohibited without the express written permission of
  23      =1  // Cypress.
  24      =1  //
  25      =1  // Disclaimer: Cypress makes no warranty of any kind, express or implied, with regard to
  26      =1  // this material, including, but not limited to, the implied warranties of merchantability and
  27      =1  // fitness for a particular purpose. Cypress reserves the right to make changes without
  28      =1  // further notice to the materials described herein. Cypress does not assume any liability
  29      =1  // arising out of the application or use of any product or circuit described herein. Cypress
  30      =1  // products described herein are not authorized for use as components in life-support
  31      =1  // devices.
  32      =1  //
  33      =1  // This software is protected by and subject to worldwide patent coverage, including U.S.
  34      =1  // and foreign patents. Use may be limited by and subject to the Cypress Software License
  35      =1  // Agreement.
  36      =1  //-----------------------------------------------------------------------------
  37      =1  #include "intrins.h"
   1      =2  /*--------------------------------------------------------------------------
   2      =2  INTRINS.H
   3      =2  
   4      =2  Intrinsic functions for C51.
   5      =2  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =2  All rights reserved.
   7      =2  --------------------------------------------------------------------------*/
   8      =2  
   9      =2  #ifndef __INTRINS_H__
  10      =2  #define __INTRINS_H__
  11      =2  
  12      =2  #pragma SAVE
  13      =2  
  14      =2  #if defined (__CX2__)
           =2 #pragma FUNCTIONS(STATIC)
           =2 /* intrinsic functions are reentrant, but need static attribute */
           =2 #endif
  18      =2  
  19      =2  extern void          _nop_     (void);
  20      =2  extern bit           _testbit_ (bit);
  21      =2  extern unsigned char _cror_    (unsigned char, unsigned char);
  22      =2  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  23      =2  extern unsigned long _lror_    (unsigned long, unsigned char);
  24      =2  extern unsigned char _crol_    (unsigned char, unsigned char);
  25      =2  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  26      =2  extern unsigned long _lrol_    (unsigned long, unsigned char);
  27      =2  extern unsigned char _chkfloat_(float);
  28      =2  #if defined (__CX2__)
           =2 extern int           abs       (int);
           =2 extern void          _illop_   (void);
           =2 #endif
  32      =2  #if !defined (__CX2__)
  33      =2  extern void          _push_    (unsigned char _sfr);
  34      =2  extern void          _pop_     (unsigned char _sfr);
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 19  

  35      =2  #endif
  36      =2  
  37      =2  #pragma RESTORE
  38      =2  
  39      =2  #endif
  40      =2  
  38      =1  
  39      =1    // Registers which require a synchronization delay, see section 15.14
  40      =1    // FIFORESET        FIFOPINPOLAR
  41      =1    // INPKTEND         OUTPKTEND
  42      =1    // EPxBCH:L         REVCTL
  43      =1    // GPIFTCB3         GPIFTCB2
  44      =1    // GPIFTCB1         GPIFTCB0
  45      =1    // EPxFIFOPFH:L     EPxAUTOINLENH:L
  46      =1    // EPxFIFOCFG       EPxGPIFFLGSEL
  47      =1    // PINFLAGSxx       EPxFIFOIRQ
  48      =1    // EPxFIFOIE        GPIFIRQ
  49      =1    // GPIFIE           GPIFADRH:L
  50      =1    // UDMACRCH:L       EPxGPIFTRIG
  51      =1    // GPIFTRIG
  52      =1    
  53      =1    // Note: The pre-REVE EPxGPIFTCH/L register are affected, as well...
  54      =1    //      ...these have been replaced by GPIFTC[B3:B0] registers
  55      =1  
  56      =1  // _IFREQ can be in the range of: 5000 to 48000
  57      =1  #ifndef _IFREQ 
  58      =1  #define _IFREQ 48000   // IFCLK frequency in kHz
  59      =1  #endif
  60      =1  
  61      =1  // CFREQ can be any one of: 48000, 24000, or 12000
  62      =1  #ifndef _CFREQ
  63      =1  #define _CFREQ 48000   // CLKOUT frequency in kHz
  64      =1  #endif
  65      =1  
  66      =1  #if( _IFREQ < 5000 )
           =1 #error "_IFREQ too small!  Valid Range: 5000 to 48000..."
           =1 #endif
  69      =1  
  70      =1  #if( _IFREQ > 48000 )
           =1 #error "_IFREQ too large!  Valid Range: 5000 to 48000..."
           =1 #endif
  73      =1  
  74      =1  #if( _CFREQ != 48000 )
           =1 #if( _CFREQ != 24000 )
           =1 #if( _CFREQ != 12000 )
           =1 #error "_CFREQ invalid!  Valid values: 48000, 24000, 12000..."
           =1 #endif
           =1 #endif
           =1 #endif
  81      =1  
  82      =1  // Synchronization Delay formula: see TRM section 15-14
  83      =1  #define _SCYCL ( 3*(_CFREQ) + 5*(_IFREQ) - 1 ) / ( 2*(_IFREQ) )
  84      =1  
  85      =1  #if( _SCYCL == 1 )
           =1 #define SYNCDELAY _nop_( )
           =1 #endif
  88      =1  
  89      =1  #if( _SCYCL == 2 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( )
           =1 #endif
  93      =1  
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 20  

  94      =1  #if( _SCYCL == 3 )
  95      =1  #define SYNCDELAY _nop_( ); \
  96      =1                    _nop_( ); \
  97      =1                    _nop_( ) 
  98      =1  #endif
  99      =1  
 100      =1  #if( _SCYCL == 4 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 106      =1  
 107      =1  #if( _SCYCL == 5 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 114      =1  
 115      =1  #if( _SCYCL == 6 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 123      =1  
 124      =1  #if( _SCYCL == 7 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 133      =1  
 134      =1  #if( _SCYCL == 8 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 144      =1  
 145      =1  #if( _SCYCL == 9 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 21  

 156      =1  
 157      =1  #if( _SCYCL == 10 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 169      =1  
 170      =1  #if( _SCYCL == 11 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 183      =1  
 184      =1  #if( _SCYCL == 12 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 198      =1  
 199      =1  #if( _SCYCL == 13 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 214      =1  
 215      =1  #if( _SCYCL == 14 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 22  

           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 231      =1  
 232      =1  #if( _SCYCL == 15 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
 249      =1  
 250      =1  #if( _SCYCL == 16 )
           =1 #define SYNCDELAY _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( ); \
           =1                   _nop_( )
           =1 #endif
  18          
  19          //-----------------------------------------------------------------------------
  20          // Constants
  21          //-----------------------------------------------------------------------------
  22          #define DELAY_COUNT   0x9248*8L  // Delay for 8 sec at 24Mhz, 4 sec at 48
  23          #define _IFREQ  48000            // IFCLK constant for Synchronization Delay
  24          #define _CFREQ  48000            // CLKOUT constant for Synchronization Delay
  25          
  26          //-----------------------------------------------------------------------------
  27          // Random Macros
  28          //-----------------------------------------------------------------------------
  29          #define   min(a,b) (((a)<(b))?(a):(b))
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 23  

  30          #define   max(a,b) (((a)>(b))?(a):(b))
  31          
  32          //-----------------------------------------------------------------------------
  33          // Global Variables
  34          //-----------------------------------------------------------------------------
  35          volatile BOOL   GotSUD;
  36          BOOL      Rwuen;
  37          BOOL      Selfpwr;
  38          volatile BOOL   Sleep;                  // Sleep mode enable flag
  39          
  40          WORD   pDeviceDscr;   // Pointer to Device Descriptor; Descriptors may be moved
  41          WORD   pDeviceQualDscr;
  42          WORD   pHighSpeedConfigDscr;
  43          WORD   pFullSpeedConfigDscr;   
  44          WORD   pConfigDscr;
  45          WORD   pOtherConfigDscr;   
  46          WORD   pStringDscr;   
  47          
  48          //-----------------------------------------------------------------------------
  49          // Prototypes
  50          //-----------------------------------------------------------------------------
  51          void SetupCommand(void);
  52          void TD_Init(void);
  53          void TD_Poll(void);
  54          BOOL TD_Suspend(void);
  55          BOOL TD_Resume(void);
  56          
  57          BOOL DR_GetDescriptor(void);
  58          BOOL DR_SetConfiguration(void);
  59          BOOL DR_GetConfiguration(void);
  60          BOOL DR_SetInterface(void);
  61          BOOL DR_GetInterface(void);
  62          BOOL DR_GetStatus(void);
  63          BOOL DR_ClearFeature(void);
  64          BOOL DR_SetFeature(void);
  65          BOOL DR_VendorCmnd(void);
  66          
  67          // this table is used by the epcs macro 
  68          const char code  EPCS_Offset_Lookup_Table[] =
  69          {
  70             0,    // EP1OUT
  71             1,    // EP1IN
  72             2,    // EP2OUT
  73             2,    // EP2IN
  74             3,    // EP4OUT
  75             3,    // EP4IN
  76             4,    // EP6OUT
  77             4,    // EP6IN
  78             5,    // EP8OUT
  79             5,    // EP8IN
  80          };
  81          
  82          // macro for generating the address of an endpoint's control and status register (EPnCS)
  83          #define epcs(EP) (EPCS_Offset_Lookup_Table[(EP & 0x7E) | (EP > 128)] + 0xE6A1)
  84          
  85          //-----------------------------------------------------------------------------
  86          // Code
  87          //-----------------------------------------------------------------------------
  88          
  89          // Task dispatcher
  90          void main(void)
  91          {
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 24  

  92   1         DWORD   i;
  93   1         WORD   offset;
  94   1         DWORD   DevDescrLen;
  95   1         DWORD   j=0;
  96   1         WORD   IntDescrAddr;
  97   1         WORD   ExtDescrAddr;
  98   1      
  99   1         // Initialize Global States
 100   1         Sleep = FALSE;               // Disable sleep mode
 101   1         Rwuen = FALSE;               // Disable remote wakeup
 102   1         Selfpwr = FALSE;            // Disable self powered
 103   1         GotSUD = FALSE;               // Clear "Got setup data" flag
 104   1      
 105   1         // Initialize user device
 106   1         TD_Init();
 107   1      
 108   1         // The following section of code is used to relocate the descriptor table. 
 109   1         // The frameworks uses SUDPTRH and SUDPTRL to automate the SETUP requests
 110   1         // for descriptors.  These registers only work with memory locations
 111   1         // in the EZ-USB internal RAM.  Therefore, if the descriptors are located
 112   1         // in external RAM, they must be copied to in internal RAM.  
 113   1         // The descriptor table is relocated by the frameworks ONLY if it is found 
 114   1         // to be located in external memory.
 115   1         pDeviceDscr = (WORD)&DeviceDscr;
 116   1         pDeviceQualDscr = (WORD)&DeviceQualDscr;
 117   1         pHighSpeedConfigDscr = (WORD)&HighSpeedConfigDscr;
 118   1         pFullSpeedConfigDscr = (WORD)&FullSpeedConfigDscr;
 119   1         pStringDscr = (WORD)&StringDscr;
 120   1      
 121   1         // Is the descriptor table in external RAM (> 16Kbytes)?  If yes,
 122   1         // then relocate.
 123   1         // Note that this code only checks if the descriptors START in 
 124   1         // external RAM.  It will not work if the descriptor table spans
 125   1         // internal and external RAM.
 126   1         if ((WORD)&DeviceDscr & 0xC000)
 127   1         {
 128   2            // first, relocate the descriptors
 129   2            IntDescrAddr = INTERNAL_DSCR_ADDR;
 130   2            ExtDescrAddr = (WORD)&DeviceDscr;
 131   2            DevDescrLen = (WORD)&UserDscr - (WORD)&DeviceDscr + 2;
 132   2            for (i = 0; i < DevDescrLen; i++)
 133   2               *((BYTE xdata *)IntDescrAddr+i) = *((BYTE xdata *)ExtDescrAddr+i);
 134   2      
 135   2            // update all of the descriptor pointers
 136   2            pDeviceDscr = IntDescrAddr;
 137   2            offset = (WORD)&DeviceDscr - INTERNAL_DSCR_ADDR;
 138   2            pDeviceQualDscr -= offset;
 139   2            pConfigDscr -= offset;
 140   2            pOtherConfigDscr -= offset;
 141   2            pHighSpeedConfigDscr -= offset;
 142   2            pFullSpeedConfigDscr -= offset;
 143   2            pStringDscr -= offset;
 144   2         }
 145   1      
 146   1         EZUSB_IRQ_ENABLE();            // Enable USB interrupt (INT2)
 147   1         EZUSB_ENABLE_RSMIRQ();            // Wake-up interrupt
 148   1      
 149   1         INTSETUP |= (bmAV2EN | bmAV4EN);     // Enable INT 2 & 4 autovectoring
 150   1      
 151   1         USBIE |= bmSUDAV | bmSUTOK | bmSUSP | bmURES | bmHSGRANT;   // Enable selected interrupts
 152   1         EA = 1;                  // Enable 8051 interrupts
 153   1      
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 25  

 154   1      #ifndef NO_RENUM
 155   1         // Renumerate if necessary.  Do this by checking the renum bit.  If it
 156   1         // is already set, there is no need to renumerate.  The renum bit will
 157   1         // already be set if this firmware was loaded from an eeprom.
 158   1         if(!(USBCS & bmRENUM))
 159   1         {
 160   2             EZUSB_Discon(TRUE);   // renumerate
 161   2         }
 162   1      #endif
 163   1      
 164   1         // unconditionally re-connect.  If we loaded from eeprom we are
 165   1         // disconnected and need to connect.  If we just renumerated this
 166   1         // is not necessary but doesn't hurt anything
 167   1         USBCS &=~bmDISCON;
 168   1      
 169   1         CKCON = (CKCON&(~bmSTRETCH)) | FW_STRETCH_VALUE; // Set stretch
 170   1      
 171   1         // clear the Sleep flag.
 172   1         Sleep = FALSE;
 173   1      
 174   1         // Task Dispatcher
 175   1         while(TRUE)               // Main Loop
 176   1         {
 177   2            // Poll User Device
 178   2            TD_Poll();
 179   2      
 180   2            // Check for pending SETUP
 181   2            if(GotSUD)
 182   2            {
 183   3               SetupCommand();          // Implement setup command
 184   3               GotSUD = FALSE;          // Clear SETUP flag
 185   3            }
 186   2      
 187   2            // check for and handle suspend.
 188   2            // NOTE: Idle mode stops the processor clock.  There are only two
 189   2            // ways out of idle mode, the WAKEUP pin, and detection of the USB
 190   2            // resume state on the USB bus.  The timers will stop and the
 191   2            // processor will not wake up on any other interrupts.
 192   2            if (Sleep)
 193   2            {
 194   3               if(TD_Suspend())
 195   3               { 
 196   4                  Sleep = FALSE;     // Clear the "go to sleep" flag.  Do it here to prevent any race condition 
             -between wakeup and the next sleep.
 197   4                  do
 198   4                  {
 199   5                     EZUSB_Susp();         // Place processor in idle mode.
 200   5                  }
 201   4                  while(!Rwuen && EZUSB_EXTWAKEUP());
 202   4                  // above.  Must continue to go back into suspend if the host has disabled remote wakeup
 203   4                  // *and* the wakeup was caused by the external wakeup pin.
 204   4      
 205   4                  // 8051 activity will resume here due to USB bus or Wakeup# pin activity.
 206   4                  EZUSB_Resume();   // If source is the Wakeup# pin, signal the host to Resume.      
 207   4                  TD_Resume();
 208   4               }   
 209   3            }
 210   2      
 211   2         }
 212   1      }
 213          
 214          BOOL HighSpeedCapable()
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 26  

 215          {
 216   1         // this function determines if the chip is high-speed capable.
 217   1         // FX2 and FX2LP are high-speed capable. FX1 is not - it does
 218   1         // not have a high-speed transceiver.
 219   1      
 220   1         if (GPCR2 & bmFULLSPEEDONLY)
 221   1            return FALSE;
 222   1         else
 223   1            return TRUE;
 224   1      }   
 225          
 226          // Device request parser
 227          void SetupCommand(void)
 228          {
 229   1         void   *dscr_ptr;
 230   1      
 231   1         switch(SETUPDAT[1])
 232   1         {
 233   2            case SC_GET_DESCRIPTOR:                  // *** Get Descriptor
 234   2               if(DR_GetDescriptor())
 235   2                  switch(SETUPDAT[3])         
 236   2                  {
 237   3                     case GD_DEVICE:            // Device
 238   3                        SUDPTRH = MSB(pDeviceDscr);
 239   3                        SUDPTRL = LSB(pDeviceDscr);
 240   3                        break;
 241   3                     case GD_DEVICE_QUALIFIER:            // Device Qualifier
 242   3                  // only retuen a device qualifier if this is a high speed
 243   3                // capable chip.
 244   3                  if (HighSpeedCapable())
 245   3                {
 246   4                          SUDPTRH = MSB(pDeviceQualDscr);
 247   4                          SUDPTRL = LSB(pDeviceQualDscr);
 248   4                }
 249   3                else
 250   3                {
 251   4                  EZUSB_STALL_EP0();
 252   4                }
 253   3                break;
 254   3                     case GD_CONFIGURATION:         // Configuration
 255   3                        SUDPTRH = MSB(pConfigDscr);
 256   3                        SUDPTRL = LSB(pConfigDscr);
 257   3                        break;
 258   3                     case GD_OTHER_SPEED_CONFIGURATION:  // Other Speed Configuration
 259   3                        SUDPTRH = MSB(pOtherConfigDscr);
 260   3                        SUDPTRL = LSB(pOtherConfigDscr);
 261   3                        break;
 262   3                     case GD_STRING:            // String
 263   3                        if(dscr_ptr = (void *)EZUSB_GetStringDscr(SETUPDAT[2]))
 264   3                        {
 265   4                           SUDPTRH = MSB(dscr_ptr);
 266   4                           SUDPTRL = LSB(dscr_ptr);
 267   4                        }
 268   3                        else 
 269   3                           EZUSB_STALL_EP0();   // Stall End Point 0
 270   3                        break;
 271   3                     default:            // Invalid request
 272   3                        EZUSB_STALL_EP0();      // Stall End Point 0
 273   3                  }
 274   2               break;
 275   2            case SC_GET_INTERFACE:                  // *** Get Interface
 276   2               DR_GetInterface();
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 27  

 277   2               break;
 278   2            case SC_SET_INTERFACE:                  // *** Set Interface
 279   2               DR_SetInterface();
 280   2               break;
 281   2            case SC_SET_CONFIGURATION:               // *** Set Configuration
 282   2               DR_SetConfiguration();
 283   2          
 284   2               break;
 285   2            case SC_GET_CONFIGURATION:               // *** Get Configuration
 286   2               DR_GetConfiguration();
 287   2               break;
 288   2            case SC_GET_STATUS:                  // *** Get Status
 289   2               if(DR_GetStatus())
 290   2                  switch(SETUPDAT[0])
 291   2                  {
 292   3                     case GS_DEVICE:            // Device
 293   3                        EP0BUF[0] = ((BYTE)Rwuen << 1) | (BYTE)Selfpwr;
 294   3                        EP0BUF[1] = 0;
 295   3                        EP0BCH = 0;
 296   3                        EP0BCL = 2;
 297   3                        break;
 298   3                     case GS_INTERFACE:         // Interface
 299   3                        EP0BUF[0] = 0;
 300   3                        EP0BUF[1] = 0;
 301   3                        EP0BCH = 0;
 302   3                        EP0BCL = 2;
 303   3                        break;
 304   3                     case GS_ENDPOINT:         // End Point
 305   3                        EP0BUF[0] = *(BYTE xdata *) epcs(SETUPDAT[4]) & bmEPSTALL;
 306   3                        EP0BUF[1] = 0;
 307   3                        EP0BCH = 0;
 308   3                        EP0BCL = 2;
 309   3                        break;
 310   3                     default:            // Invalid Command
 311   3                        EZUSB_STALL_EP0();      // Stall End Point 0
 312   3                  }
 313   2               break;
 314   2            case SC_CLEAR_FEATURE:                  // *** Clear Feature
 315   2               if(DR_ClearFeature())
 316   2                  switch(SETUPDAT[0])
 317   2                  {
 318   3                     case FT_DEVICE:            // Device
 319   3                        if(SETUPDAT[2] == 1)
 320   3                           Rwuen = FALSE;       // Disable Remote Wakeup
 321   3                        else
 322   3                           EZUSB_STALL_EP0();   // Stall End Point 0
 323   3                        break;
 324   3                     case FT_ENDPOINT:         // End Point
 325   3                        if(SETUPDAT[2] == 0)
 326   3                        {
 327   4                           *(BYTE xdata *) epcs(SETUPDAT[4]) &= ~bmEPSTALL;
 328   4                           EZUSB_RESET_DATA_TOGGLE( SETUPDAT[4] );
 329   4                        }
 330   3                        else
 331   3                           EZUSB_STALL_EP0();   // Stall End Point 0
 332   3                        break;
 333   3                  }
 334   2               break;
 335   2            case SC_SET_FEATURE:                  // *** Set Feature
 336   2               if(DR_SetFeature())
 337   2                  switch(SETUPDAT[0])
 338   2                  {
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 28  

 339   3                     case FT_DEVICE:            // Device
 340   3                        if(SETUPDAT[2] == 1)
 341   3                           Rwuen = TRUE;      // Enable Remote Wakeup
 342   3                        else if(SETUPDAT[2] == 2)
 343   3                           // Set Feature Test Mode.  The core handles this request.  However, it is
 344   3                           // necessary for the firmware to complete the handshake phase of the
 345   3                           // control transfer before the chip will enter test mode.  It is also
 346   3                           // necessary for FX2 to be physically disconnected (D+ and D-)
 347   3                           // from the host before it will enter test mode.
 348   3                           break;
 349   3                        else
 350   3                           EZUSB_STALL_EP0();   // Stall End Point 0
 351   3                        break;
 352   3                     case FT_ENDPOINT:         // End Point
 353   3                        *(BYTE xdata *) epcs(SETUPDAT[4]) |= bmEPSTALL;
 354   3                        break;
 355   3                     default:
 356   3                        EZUSB_STALL_EP0();      // Stall End Point 0
 357   3                  }
 358   2               break;
 359   2            default:                     // *** Invalid Command
 360   2               if(DR_VendorCmnd())
 361   2                  EZUSB_STALL_EP0();            // Stall End Point 0
 362   2         }
 363   1      
 364   1         // Acknowledge handshake phase of device request
 365   1         EP0CS |= bmHSNAK;
 366   1      }
 367          
 368          // Wake-up interrupt handler
 369          void resume_isr(void) interrupt WKUP_VECT
 370          {
 371   1         EZUSB_CLEAR_RSMIRQ();
 372   1      }
 373          
 374          
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 90
                                           ; SOURCE LINE # 91
                                           ; SOURCE LINE # 95
0000 E4                CLR     A
0001 F500        R     MOV     j+03H,A
0003 F500        R     MOV     j+02H,A
0005 F500        R     MOV     j+01H,A
0007 F500        R     MOV     j,A
                                           ; SOURCE LINE # 100
0009 C200        R     CLR     Sleep
                                           ; SOURCE LINE # 101
000B C200        R     CLR     Rwuen
                                           ; SOURCE LINE # 102
000D C200        R     CLR     Selfpwr
                                           ; SOURCE LINE # 103
000F C200        R     CLR     GotSUD
                                           ; SOURCE LINE # 106
0011 120000      E     LCALL   TD_Init
                                           ; SOURCE LINE # 115
0014 7E00        E     MOV     R6,#HIGH DeviceDscr
0016 7F00        E     MOV     R7,#LOW DeviceDscr
0018 8E00        R     MOV     pDeviceDscr,R6
001A 8F00        R     MOV     pDeviceDscr+01H,R7
                                           ; SOURCE LINE # 116
001C 750000      E     MOV     pDeviceQualDscr,#HIGH DeviceQualDscr
001F 750000      E     MOV     pDeviceQualDscr+01H,#LOW DeviceQualDscr
                                           ; SOURCE LINE # 117
0022 750000      E     MOV     pHighSpeedConfigDscr,#HIGH HighSpeedConfigDscr
0025 750000      E     MOV     pHighSpeedConfigDscr+01H,#LOW HighSpeedConfigDscr
                                           ; SOURCE LINE # 118
0028 750000      E     MOV     pFullSpeedConfigDscr,#HIGH FullSpeedConfigDscr
002B 750000      E     MOV     pFullSpeedConfigDscr+01H,#LOW FullSpeedConfigDscr
                                           ; SOURCE LINE # 119
002E 750000      E     MOV     pStringDscr,#HIGH StringDscr
0031 750000      E     MOV     pStringDscr+01H,#LOW StringDscr
                                           ; SOURCE LINE # 126
0034 EE                MOV     A,R6
0035 54C0              ANL     A,#0C0H
0037 7003              JNZ     $ + 5H
0039 020000      R     LJMP    ?C0001
                                           ; SOURCE LINE # 127
                                           ; SOURCE LINE # 129
003C 750000      R     MOV     IntDescrAddr,#00H
003F 750080      R     MOV     IntDescrAddr+01H,#080H
                                           ; SOURCE LINE # 130
0042 8E00        R     MOV     ExtDescrAddr,R6
0044 8F00        R     MOV     ExtDescrAddr+01H,R7
                                           ; SOURCE LINE # 131
0046 C3                CLR     C
0047 7400        E     MOV     A,#LOW UserDscr
0049 9F                SUBB    A,R7
004A FF                MOV     R7,A
004B 7400        E     MOV     A,#HIGH UserDscr
004D 9E                SUBB    A,R6
004E CF                XCH     A,R7
004F 2402              ADD     A,#02H
0051 CF                XCH     A,R7
0052 3400              ADDC    A,#00H
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 30  

0054 FE                MOV     R6,A
0055 E4                CLR     A
0056 8F00        R     MOV     DevDescrLen+03H,R7
0058 8E00        R     MOV     DevDescrLen+02H,R6
005A F500        R     MOV     DevDescrLen+01H,A
005C F500        R     MOV     DevDescrLen,A
                                           ; SOURCE LINE # 132
005E F500        R     MOV     i+03H,A
0060 F500        R     MOV     i+02H,A
0062 F500        R     MOV     i+01H,A
0064 F500        R     MOV     i,A
0066         ?C0002:
0066 AF00        R     MOV     R7,DevDescrLen+03H
0068 AE00        R     MOV     R6,DevDescrLen+02H
006A AD00        R     MOV     R5,DevDescrLen+01H
006C AC00        R     MOV     R4,DevDescrLen
006E AB00        R     MOV     R3,i+03H
0070 AA00        R     MOV     R2,i+02H
0072 A900        R     MOV     R1,i+01H
0074 A800        R     MOV     R0,i
0076 C3                CLR     C
0077 120000      E     LCALL   ?C?ULCMP
007A 5033              JNC     ?C0003
                                           ; SOURCE LINE # 133
007C E500        R     MOV     A,ExtDescrAddr+01H
007E 2500        R     ADD     A,i+03H
0080 F582              MOV     DPL,A
0082 E500        R     MOV     A,ExtDescrAddr
0084 3500        R     ADDC    A,i+02H
0086 F583              MOV     DPH,A
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A E500        R     MOV     A,IntDescrAddr+01H
008C 2500        R     ADD     A,i+03H
008E F582              MOV     DPL,A
0090 E500        R     MOV     A,IntDescrAddr
0092 3500        R     ADDC    A,i+02H
0094 F583              MOV     DPH,A
0096 EF                MOV     A,R7
0097 F0                MOVX    @DPTR,A
0098 E500        R     MOV     A,i+03H
009A 2401              ADD     A,#01H
009C F500        R     MOV     i+03H,A
009E E4                CLR     A
009F 3500        R     ADDC    A,i+02H
00A1 F500        R     MOV     i+02H,A
00A3 E4                CLR     A
00A4 3500        R     ADDC    A,i+01H
00A6 F500        R     MOV     i+01H,A
00A8 E4                CLR     A
00A9 3500        R     ADDC    A,i
00AB F500        R     MOV     i,A
00AD 80B7              SJMP    ?C0002
00AF         ?C0003:
                                           ; SOURCE LINE # 136
00AF 850000      R     MOV     pDeviceDscr,IntDescrAddr
00B2 850000      R     MOV     pDeviceDscr+01H,IntDescrAddr+01H
                                           ; SOURCE LINE # 137
00B5 7400        E     MOV     A,#LOW DeviceDscr
00B7 2480              ADD     A,#080H
00B9 FF                MOV     R7,A
00BA 7400        E     MOV     A,#HIGH DeviceDscr
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 31  

00BC 34FF              ADDC    A,#0FFH
00BE FE                MOV     R6,A
;---- Variable 'offset' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 138
00BF C3                CLR     C
00C0 E500        R     MOV     A,pDeviceQualDscr+01H
00C2 9F                SUBB    A,R7
00C3 F500        R     MOV     pDeviceQualDscr+01H,A
00C5 E500        R     MOV     A,pDeviceQualDscr
00C7 9E                SUBB    A,R6
00C8 F500        R     MOV     pDeviceQualDscr,A
                                           ; SOURCE LINE # 139
00CA C3                CLR     C
00CB E500        R     MOV     A,pConfigDscr+01H
00CD 9F                SUBB    A,R7
00CE F500        R     MOV     pConfigDscr+01H,A
00D0 E500        R     MOV     A,pConfigDscr
00D2 9E                SUBB    A,R6
00D3 F500        R     MOV     pConfigDscr,A
                                           ; SOURCE LINE # 140
00D5 C3                CLR     C
00D6 E500        R     MOV     A,pOtherConfigDscr+01H
00D8 9F                SUBB    A,R7
00D9 F500        R     MOV     pOtherConfigDscr+01H,A
00DB E500        R     MOV     A,pOtherConfigDscr
00DD 9E                SUBB    A,R6
00DE F500        R     MOV     pOtherConfigDscr,A
                                           ; SOURCE LINE # 141
00E0 C3                CLR     C
00E1 E500        R     MOV     A,pHighSpeedConfigDscr+01H
00E3 9F                SUBB    A,R7
00E4 F500        R     MOV     pHighSpeedConfigDscr+01H,A
00E6 E500        R     MOV     A,pHighSpeedConfigDscr
00E8 9E                SUBB    A,R6
00E9 F500        R     MOV     pHighSpeedConfigDscr,A
                                           ; SOURCE LINE # 142
00EB C3                CLR     C
00EC E500        R     MOV     A,pFullSpeedConfigDscr+01H
00EE 9F                SUBB    A,R7
00EF F500        R     MOV     pFullSpeedConfigDscr+01H,A
00F1 E500        R     MOV     A,pFullSpeedConfigDscr
00F3 9E                SUBB    A,R6
00F4 F500        R     MOV     pFullSpeedConfigDscr,A
                                           ; SOURCE LINE # 143
00F6 C3                CLR     C
00F7 E500        R     MOV     A,pStringDscr+01H
00F9 9F                SUBB    A,R7
00FA F500        R     MOV     pStringDscr+01H,A
00FC E500        R     MOV     A,pStringDscr
00FE 9E                SUBB    A,R6
00FF F500        R     MOV     pStringDscr,A
                                           ; SOURCE LINE # 144
0101         ?C0001:
                                           ; SOURCE LINE # 146
0101 D2E8              SETB    EUSB
                                           ; SOURCE LINE # 147
0103 43D820            ORL     EICON,#020H
                                           ; SOURCE LINE # 149
0106 900000      E     MOV     DPTR,#INTSETUP
0109 E0                MOVX    A,@DPTR
010A 4409              ORL     A,#09H
010C F0                MOVX    @DPTR,A
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 32  

                                           ; SOURCE LINE # 151
010D 900000      E     MOV     DPTR,#USBIE
0110 E0                MOVX    A,@DPTR
0111 443D              ORL     A,#03DH
0113 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 152
0114 D2AF              SETB    EA
                                           ; SOURCE LINE # 158
0116 900000      E     MOV     DPTR,#USBCS
0119 E0                MOVX    A,@DPTR
011A 20E105            JB      ACC.1,?C0005
                                           ; SOURCE LINE # 159
                                           ; SOURCE LINE # 160
011D D200        E     SETB    ?EZUSB_Discon?BIT
011F 120000      E     LCALL   EZUSB_Discon
                                           ; SOURCE LINE # 161
0122         ?C0005:
                                           ; SOURCE LINE # 167
0122 900000      E     MOV     DPTR,#USBCS
0125 E0                MOVX    A,@DPTR
0126 54F7              ANL     A,#0F7H
0128 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 169
0129 538EF8            ANL     CKCON,#0F8H
                                           ; SOURCE LINE # 172
012C C200        R     CLR     Sleep
012E         ?C0006:
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 176
                                           ; SOURCE LINE # 178
012E 120000      E     LCALL   TD_Poll
                                           ; SOURCE LINE # 181
0131 300005      R     JNB     GotSUD,?C0008
                                           ; SOURCE LINE # 182
                                           ; SOURCE LINE # 183
0134 120000      R     LCALL   SetupCommand
                                           ; SOURCE LINE # 184
0137 C200        R     CLR     GotSUD
                                           ; SOURCE LINE # 185
0139         ?C0008:
                                           ; SOURCE LINE # 192
0139 3000F2      R     JNB     Sleep,?C0006
                                           ; SOURCE LINE # 193
                                           ; SOURCE LINE # 194
013C 120000      E     LCALL   TD_Suspend
013F 50ED              JNC     ?C0006
                                           ; SOURCE LINE # 195
                                           ; SOURCE LINE # 196
0141 C200        R     CLR     Sleep
0143         ?C0013:
                                           ; SOURCE LINE # 198
                                           ; SOURCE LINE # 199
0143 120000      E     LCALL   EZUSB_Susp
                                           ; SOURCE LINE # 200
                                           ; SOURCE LINE # 201
0146 200016      R     JB      Rwuen,?C0012
0149 900000      E     MOV     DPTR,#WAKEUPCS
014C E0                MOVX    A,@DPTR
014D 30E704            JNB     ACC.7,?C0015
0150 E0                MOVX    A,@DPTR
0151 20E1EF            JB      ACC.1,?C0013
0154         ?C0015:
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 33  

0154 900000      E     MOV     DPTR,#WAKEUPCS
0157 E0                MOVX    A,@DPTR
0158 30E604            JNB     ACC.6,?C0012
015B E0                MOVX    A,@DPTR
015C 20E0E4            JB      ACC.0,?C0013
015F         ?C0012:
                                           ; SOURCE LINE # 206
015F 120000      E     LCALL   EZUSB_Resume
                                           ; SOURCE LINE # 207
0162 120000      E     LCALL   TD_Resume
                                           ; SOURCE LINE # 208
                                           ; SOURCE LINE # 209
                                           ; SOURCE LINE # 211
0165 80C7              SJMP    ?C0006
             ; FUNCTION main (END)

             ; FUNCTION HighSpeedCapable (BEGIN)
                                           ; SOURCE LINE # 214
                                           ; SOURCE LINE # 215
                                           ; SOURCE LINE # 220
0000 900000      E     MOV     DPTR,#GPCR2
0003 E0                MOVX    A,@DPTR
0004 30E402            JNB     ACC.4,?C0018
                                           ; SOURCE LINE # 221
0007 C3                CLR     C
0008 22                RET     
0009         ?C0018:
                                           ; SOURCE LINE # 223
0009 D3                SETB    C
                                           ; SOURCE LINE # 224
000A         ?C0019:
000A 22                RET     
             ; FUNCTION HighSpeedCapable (END)

             ; FUNCTION SetupCommand (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 231
0000 900000      E     MOV     DPTR,#SETUPDAT+01H
0003 E0                MOVX    A,@DPTR
0004 7003              JNZ     $ + 5H
0006 020000      R     LJMP    ?C0039
0009 14                DEC     A
000A 7003              JNZ     $ + 5H
000C 020000      R     LJMP    ?C0048
000F 24FE              ADD     A,#0FEH
0011 7003              JNZ     $ + 5H
0013 020000      R     LJMP    ?C0059
0016 24FB              ADD     A,#0FBH
0018 7003              JNZ     $ + 5H
001A 020000      R     LJMP    ?C0038
001D 14                DEC     A
001E 7003              JNZ     $ + 5H
0020 020000      R     LJMP    ?C0037
0023 14                DEC     A
0024 7003              JNZ     $ + 5H
0026 020000      R     LJMP    ?C0035
0029 14                DEC     A
002A 7003              JNZ     $ + 5H
002C 020000      R     LJMP    ?C0036
002F 2405              ADD     A,#05H
0031 6003              JZ      $ + 5H
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 34  

0033 020000      R     LJMP    ?C0071
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 233
0036         ?C0022:
                                           ; SOURCE LINE # 234
0036 120000      E     LCALL   DR_GetDescriptor
0039 4003              JC      $ + 5H
003B 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 235
003E 900000      E     MOV     DPTR,#SETUPDAT+03H
0041 E0                MOVX    A,@DPTR
0042 24FE              ADD     A,#0FEH
0044 6027              JZ      ?C0029
0046 14                DEC     A
0047 6038              JZ      ?C0031
0049 24FD              ADD     A,#0FDH
004B 6011              JZ      ?C0026
004D 14                DEC     A
004E 6027              JZ      ?C0030
0050 2406              ADD     A,#06H
0052 7050              JNZ     ?C0034
                                           ; SOURCE LINE # 236
                                           ; SOURCE LINE # 237
0054         ?C0025:
                                           ; SOURCE LINE # 238
0054 E500        R     MOV     A,pDeviceDscr
0056 900000      E     MOV     DPTR,#SUDPTRH
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 239
005A E500        R     MOV     A,pDeviceDscr+01H
                                           ; SOURCE LINE # 240
005C 803C              SJMP    ?C0079
                                           ; SOURCE LINE # 241
005E         ?C0026:
                                           ; SOURCE LINE # 244
005E 120000      R     LCALL   HighSpeedCapable
0061 503E              JNC     ?C0077
                                           ; SOURCE LINE # 245
                                           ; SOURCE LINE # 246
0063 E500        R     MOV     A,pDeviceQualDscr
0065 900000      E     MOV     DPTR,#SUDPTRH
0068 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 247
0069 E500        R     MOV     A,pDeviceQualDscr+01H
006B         ?C0075:
                                           ; SOURCE LINE # 248
006B 802D              SJMP    ?C0079
                                           ; SOURCE LINE # 254
006D         ?C0029:
                                           ; SOURCE LINE # 255
006D E500        R     MOV     A,pConfigDscr
006F 900000      E     MOV     DPTR,#SUDPTRH
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 256
0073 E500        R     MOV     A,pConfigDscr+01H
0075         ?C0076:
                                           ; SOURCE LINE # 257
0075 8023              SJMP    ?C0079
                                           ; SOURCE LINE # 258
0077         ?C0030:
                                           ; SOURCE LINE # 259
0077 E500        R     MOV     A,pOtherConfigDscr
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 35  

0079 900000      E     MOV     DPTR,#SUDPTRH
007C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 260
007D E500        R     MOV     A,pOtherConfigDscr+01H
007F         ?C0078:
                                           ; SOURCE LINE # 261
007F 8019              SJMP    ?C0079
                                           ; SOURCE LINE # 262
0081         ?C0031:
                                           ; SOURCE LINE # 263
0081 900000      E     MOV     DPTR,#SETUPDAT+02H
0084 E0                MOVX    A,@DPTR
0085 FF                MOV     R7,A
0086 120000      E     LCALL   _EZUSB_GetStringDscr
0089 AA06              MOV     R2,AR6
008B A907              MOV     R1,AR7
008D 7B01              MOV     R3,#01H
;---- Variable 'dscr_ptr' assigned to Register 'R1/R2/R3' ----
008F EA                MOV     A,R2
0090 49                ORL     A,R1
0091 4B                ORL     A,R3
0092 600D              JZ      ?C0032
                                           ; SOURCE LINE # 264
                                           ; SOURCE LINE # 265
0094 EE                MOV     A,R6
0095 900000      E     MOV     DPTR,#SUDPTRH
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 266
0099 EF                MOV     A,R7
009A         ?C0079:
009A 900000      E     MOV     DPTR,#SUDPTRL
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 267
009E 020000      R     LJMP    ?C0021
00A1         ?C0032:
                                           ; SOURCE LINE # 269
00A1         ?C0077:
                                           ; SOURCE LINE # 270
00A1 020000      R     LJMP    ?C0087
                                           ; SOURCE LINE # 271
00A4         ?C0034:
                                           ; SOURCE LINE # 272
00A4         ?C0080:
                                           ; SOURCE LINE # 273
                                           ; SOURCE LINE # 274
00A4 020000      R     LJMP    ?C0087
                                           ; SOURCE LINE # 275
00A7         ?C0035:
                                           ; SOURCE LINE # 276
00A7 120000      E     LCALL   DR_GetInterface
                                           ; SOURCE LINE # 277
00AA 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 278
00AD         ?C0036:
                                           ; SOURCE LINE # 279
00AD 120000      E     LCALL   DR_SetInterface
                                           ; SOURCE LINE # 280
00B0 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 281
00B3         ?C0037:
                                           ; SOURCE LINE # 282
00B3 120000      E     LCALL   DR_SetConfiguration
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 36  

                                           ; SOURCE LINE # 284
00B6 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 285
00B9         ?C0038:
                                           ; SOURCE LINE # 286
00B9 120000      E     LCALL   DR_GetConfiguration
                                           ; SOURCE LINE # 287
00BC 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 288
00BF         ?C0039:
                                           ; SOURCE LINE # 289
00BF 120000      E     LCALL   DR_GetStatus
00C2 4003              JC      $ + 5H
00C4 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 290
00C7 900000      E     MOV     DPTR,#SETUPDAT
00CA E0                MOVX    A,@DPTR
00CB 247F              ADD     A,#07FH
00CD 6015              JZ      ?C0043
00CF 14                DEC     A
00D0 6019              JZ      ?C0044
00D2 2402              ADD     A,#02H
00D4 7063              JNZ     ?C0047
                                           ; SOURCE LINE # 291
                                           ; SOURCE LINE # 292
00D6         ?C0042:
                                           ; SOURCE LINE # 293
00D6 A200        R     MOV     C,Rwuen
00D8 E4                CLR     A
00D9 33                RLC     A
00DA 25E0              ADD     A,ACC
00DC FF                MOV     R7,A
00DD A200        R     MOV     C,Selfpwr
00DF E4                CLR     A
00E0 33                RLC     A
00E1 4F                ORL     A,R7
                                           ; SOURCE LINE # 294
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 297
00E2 8041              SJMP    ?C0082
                                           ; SOURCE LINE # 298
00E4         ?C0043:
                                           ; SOURCE LINE # 299
00E4 E4                CLR     A
00E5 900000      E     MOV     DPTR,#EP0BUF
00E8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 300
                                           ; SOURCE LINE # 301
                                           ; SOURCE LINE # 302
                                           ; SOURCE LINE # 303
00E9 803F              SJMP    ?C0083
                                           ; SOURCE LINE # 304
00EB         ?C0044:
                                           ; SOURCE LINE # 305
00EB 900000      E     MOV     DPTR,#SETUPDAT+04H
00EE E0                MOVX    A,@DPTR
00EF 547E              ANL     A,#07EH
00F1 FF                MOV     R7,A
00F2 7E00              MOV     R6,#00H
00F4 E0                MOVX    A,@DPTR
00F5 D3                SETB    C
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 37  

00F6 9480              SUBB    A,#080H
00F8 7C00              MOV     R4,#00H
00FA 4004              JC      ?C0045
00FC 7D01              MOV     R5,#01H
00FE 8002              SJMP    ?C0046
0100         ?C0045:
0100 7D00              MOV     R5,#00H
0102         ?C0046:
0102 EC                MOV     A,R4
0103 4E                ORL     A,R6
0104 FE                MOV     R6,A
0105 ED                MOV     A,R5
0106 4F                ORL     A,R7
0107 2400        R     ADD     A,#LOW EPCS_Offset_Lookup_Table
0109 F582              MOV     DPL,A
010B 7400        R     MOV     A,#HIGH EPCS_Offset_Lookup_Table
010D 3E                ADDC    A,R6
010E F583              MOV     DPH,A
0110 E4                CLR     A
0111 93                MOVC    A,@A+DPTR
0112 FF                MOV     R7,A
0113 33                RLC     A
0114 95E0              SUBB    A,ACC
0116 FE                MOV     R6,A
0117 EF                MOV     A,R7
0118 24A1              ADD     A,#0A1H
011A FF                MOV     R7,A
011B EE                MOV     A,R6
011C 34E6              ADDC    A,#0E6H
011E 8F82              MOV     DPL,R7
0120 F583              MOV     DPH,A
0122 E0                MOVX    A,@DPTR
0123 5401              ANL     A,#01H
0125         ?C0082:
0125 900000      E     MOV     DPTR,#EP0BUF
0128 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 306
0129 E4                CLR     A
012A         ?C0083:
012A A3                INC     DPTR
012B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 307
012C 900000      E     MOV     DPTR,#EP0BCH
012F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 308
0130 900000      E     MOV     DPTR,#EP0BCL
0133 7402              MOV     A,#02H
0135 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 309
0136 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 310
0139         ?C0047:
                                           ; SOURCE LINE # 311
0139         ?C0081:
                                           ; SOURCE LINE # 312
                                           ; SOURCE LINE # 313
0139 020000      R     LJMP    ?C0087
                                           ; SOURCE LINE # 314
013C         ?C0048:
                                           ; SOURCE LINE # 315
013C 120000      E     LCALL   DR_ClearFeature
013F 4003              JC      $ + 5H
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 38  

0141 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 316
0144 900000      E     MOV     DPTR,#SETUPDAT
0147 E0                MOVX    A,@DPTR
0148 24FE              ADD     A,#0FEH
014A 6016              JZ      ?C0054
014C 2402              ADD     A,#02H
014E 6003              JZ      $ + 5H
0150 020000      R     LJMP    ?C0021
                                           ; SOURCE LINE # 317
                                           ; SOURCE LINE # 318
0153         ?C0051:
                                           ; SOURCE LINE # 319
0153 900000      E     MOV     DPTR,#SETUPDAT+02H
0156 E0                MOVX    A,@DPTR
0157 B40105            CJNE    A,#01H,?C0052
                                           ; SOURCE LINE # 320
015A C200        R     CLR     Rwuen
015C 020000      R     LJMP    ?C0021
015F         ?C0052:
                                           ; SOURCE LINE # 322
015F         ?C0084:
                                           ; SOURCE LINE # 323
015F 020000      R     LJMP    ?C0087
                                           ; SOURCE LINE # 324
0162         ?C0054:
                                           ; SOURCE LINE # 325
0162 900000      E     MOV     DPTR,#SETUPDAT+02H
0165 E0                MOVX    A,@DPTR
0166 7055              JNZ     ?C0055
                                           ; SOURCE LINE # 326
                                           ; SOURCE LINE # 327
0168 900000      E     MOV     DPTR,#SETUPDAT+04H
016B E0                MOVX    A,@DPTR
016C 547E              ANL     A,#07EH
016E FF                MOV     R7,A
016F 7E00              MOV     R6,#00H
0171 E0                MOVX    A,@DPTR
0172 D3                SETB    C
0173 9480              SUBB    A,#080H
0175 7C00              MOV     R4,#00H
0177 4004              JC      ?C0056
0179 7D01              MOV     R5,#01H
017B 8002              SJMP    ?C0057
017D         ?C0056:
017D 7D00              MOV     R5,#00H
017F         ?C0057:
017F EC                MOV     A,R4
0180 4E                ORL     A,R6
0181 FE                MOV     R6,A
0182 ED                MOV     A,R5
0183 4F                ORL     A,R7
0184 2400        R     ADD     A,#LOW EPCS_Offset_Lookup_Table
0186 F582              MOV     DPL,A
0188 7400        R     MOV     A,#HIGH EPCS_Offset_Lookup_Table
018A 3E                ADDC    A,R6
018B F583              MOV     DPH,A
018D E4                CLR     A
018E 93                MOVC    A,@A+DPTR
018F FF                MOV     R7,A
0190 33                RLC     A
0191 95E0              SUBB    A,ACC
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 39  

0193 FE                MOV     R6,A
0194 EF                MOV     A,R7
0195 24A1              ADD     A,#0A1H
0197 FF                MOV     R7,A
0198 EE                MOV     A,R6
0199 34E6              ADDC    A,#0E6H
019B 8F82              MOV     DPL,R7
019D F583              MOV     DPH,A
019F E0                MOVX    A,@DPTR
01A0 54FE              ANL     A,#0FEH
01A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 328
01A3 900000      E     MOV     DPTR,#SETUPDAT+04H
01A6 E0                MOVX    A,@DPTR
01A7 5480              ANL     A,#080H
01A9 13                RRC     A
01AA 13                RRC     A
01AB 13                RRC     A
01AC 541F              ANL     A,#01FH
01AE FF                MOV     R7,A
01AF E0                MOVX    A,@DPTR
01B0 540F              ANL     A,#0FH
01B2 2F                ADD     A,R7
01B3 900000      E     MOV     DPTR,#TOGCTL
01B6 F0                MOVX    @DPTR,A
01B7 E0                MOVX    A,@DPTR
01B8 4420              ORL     A,#020H
01BA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 329
01BB 8073              SJMP    ?C0021
01BD         ?C0055:
                                           ; SOURCE LINE # 331
01BD         ?C0085:
                                           ; SOURCE LINE # 332
01BD 8060              SJMP    ?C0087
                                           ; SOURCE LINE # 333
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
01BF         ?C0059:
                                           ; SOURCE LINE # 336
01BF 120000      E     LCALL   DR_SetFeature
01C2 506C              JNC     ?C0021
                                           ; SOURCE LINE # 337
01C4 900000      E     MOV     DPTR,#SETUPDAT
01C7 E0                MOVX    A,@DPTR
01C8 24FE              ADD     A,#0FEH
01CA 601A              JZ      ?C0067
01CC 2402              ADD     A,#02H
01CE 704F              JNZ     ?C0070
                                           ; SOURCE LINE # 338
                                           ; SOURCE LINE # 339
01D0         ?C0062:
                                           ; SOURCE LINE # 340
01D0 900000      E     MOV     DPTR,#SETUPDAT+02H
01D3 E0                MOVX    A,@DPTR
01D4 B40104            CJNE    A,#01H,?C0063
                                           ; SOURCE LINE # 341
01D7 D200        R     SETB    Rwuen
01D9 8055              SJMP    ?C0021
01DB         ?C0063:
                                           ; SOURCE LINE # 342
01DB 900000      E     MOV     DPTR,#SETUPDAT+02H
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 40  

01DE E0                MOVX    A,@DPTR
01DF B40202            CJNE    A,#02H,?C0065
                                           ; SOURCE LINE # 348
01E2 804C              SJMP    ?C0021
01E4         ?C0065:
                                           ; SOURCE LINE # 350
01E4         ?C0086:
                                           ; SOURCE LINE # 351
01E4 8039              SJMP    ?C0087
                                           ; SOURCE LINE # 352
01E6         ?C0067:
                                           ; SOURCE LINE # 353
01E6 900000      E     MOV     DPTR,#SETUPDAT+04H
01E9 E0                MOVX    A,@DPTR
01EA 547E              ANL     A,#07EH
01EC FF                MOV     R7,A
01ED 7E00              MOV     R6,#00H
01EF E0                MOVX    A,@DPTR
01F0 D3                SETB    C
01F1 9480              SUBB    A,#080H
01F3 7C00              MOV     R4,#00H
01F5 4004              JC      ?C0068
01F7 7D01              MOV     R5,#01H
01F9 8002              SJMP    ?C0069
01FB         ?C0068:
01FB 7D00              MOV     R5,#00H
01FD         ?C0069:
01FD EC                MOV     A,R4
01FE 4E                ORL     A,R6
01FF FE                MOV     R6,A
0200 ED                MOV     A,R5
0201 4F                ORL     A,R7
0202 2400        R     ADD     A,#LOW EPCS_Offset_Lookup_Table
0204 F582              MOV     DPL,A
0206 7400        R     MOV     A,#HIGH EPCS_Offset_Lookup_Table
0208 3E                ADDC    A,R6
0209 F583              MOV     DPH,A
020B E4                CLR     A
020C 93                MOVC    A,@A+DPTR
020D FF                MOV     R7,A
020E 33                RLC     A
020F 95E0              SUBB    A,ACC
0211 FE                MOV     R6,A
0212 EF                MOV     A,R7
0213 24A1              ADD     A,#0A1H
0215 FF                MOV     R7,A
0216 EE                MOV     A,R6
0217 34E6              ADDC    A,#0E6H
0219 8F82              MOV     DPL,R7
021B F583              MOV     DPH,A
                                           ; SOURCE LINE # 354
021D 800D              SJMP    ?C0089
                                           ; SOURCE LINE # 355
021F         ?C0070:
                                           ; SOURCE LINE # 356
021F         ?C0087:
021F 900000      E     MOV     DPTR,#EP0CS
0222         ?C0088:
                                           ; SOURCE LINE # 357
                                           ; SOURCE LINE # 358
0222 8008              SJMP    ?C0089
                                           ; SOURCE LINE # 359
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 41  

0224         ?C0071:
                                           ; SOURCE LINE # 360
0224 120000      E     LCALL   DR_VendorCmnd
0227 5007              JNC     ?C0021
                                           ; SOURCE LINE # 361
0229 900000      E     MOV     DPTR,#EP0CS
022C         ?C0089:
022C E0                MOVX    A,@DPTR
022D 4401              ORL     A,#01H
022F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 362
0230         ?C0021:
                                           ; SOURCE LINE # 365
0230 900000      E     MOV     DPTR,#EP0CS
0233 E0                MOVX    A,@DPTR
0234 4480              ORL     A,#080H
0236 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 366
0237 22                RET     
             ; FUNCTION SetupCommand (END)

             ; FUNCTION resume_isr (BEGIN)
                                           ; SOURCE LINE # 369
                                           ; SOURCE LINE # 371
0000 53D8EF            ANL     EICON,#0EFH
                                           ; SOURCE LINE # 372
0003 32                RETI    
             ; FUNCTION resume_isr (END)

C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 42  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


INTSETUP . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
USBCS. . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
DR_SetConfiguration. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
STRINGDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
StringDscr . . . . . . . . . . . . . .  EXTERN   CODE   STRUCT   -----  2
TD_Init. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TD_Poll. . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Rwuen. . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
EP0BCH . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
DEVICEQUALDSCR . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  10
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  spec_ver_minor . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  spec_ver_major . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  dev_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  max_packet . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  configs. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  reserved0. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
EP0BCL . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
_EZUSB_GetStringDscr . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
GotSUD . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
EZUSB_Susp . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
DR_GetStatus . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EPCS_Offset_Lookup_Table . . . . . . .  PUBLIC   CODE   ARRAY    0000H  10
HighSpeedCapable . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
EP0BUF . . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  64
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  i. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0000H  4
  offset . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0006H  2
  DevDescrLen. . . . . . . . . . . . .  AUTO     DATA   U_LONG   0004H  4
  j. . . . . . . . . . . . . . . . . .  AUTO     DATA   U_LONG   0008H  4
  IntDescrAddr . . . . . . . . . . . .  AUTO     DATA   U_INT    000CH  2
  ExtDescrAddr . . . . . . . . . . . .  AUTO     DATA   U_INT    000EH  2
SUDPTRH. . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
DSCR . . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
BOOL . . . . . . . . . . . . . . . . .  TYPEDEF  DATA   BIT      -----  1
DR_GetInterface. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
EUSB . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00E8H  1
UserDscr . . . . . . . . . . . . . . .  EXTERN   CODE   STRUCT   -----  2
SUDPTRL. . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
DR_ClearFeature. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
DR_SetInterface. . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
DR_GetDescriptor . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
resume_isr . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
TOGCTL . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
EZUSB_Discon . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
pHighSpeedConfigDscr . . . . . . . . .  PUBLIC   DATA   U_INT    0000H  2
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 43  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


pDeviceDscr. . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0002H  2
SetupCommand . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  dscr_ptr . . . . . . . . . . . . . .  * REG *  DATA   VOID_PTR 0001H  3
pConfigDscr. . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    0004H  2
EP0CS. . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
TD_Suspend . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
GPCR2. . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
pOtherConfigDscr . . . . . . . . . . .  PUBLIC   DATA   U_INT    0006H  2
EZUSB_Resume . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
HighSpeedConfigDscr. . . . . . . . . .  EXTERN   CODE   STRUCT   -----  9
DEVICEDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  18
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  spec_ver_minor . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  spec_ver_major . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  dev_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  max_packet . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  vendor_id. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  product_id . . . . . . . . . . . . .  MEMBER   -----  U_INT    000AH  2
  version_id . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
  mfg_str. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  prod_str . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
  serialnum_str. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  configs. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0011H  1
DeviceDscr . . . . . . . . . . . . . .  EXTERN   CODE   STRUCT   -----  18
pFullSpeedConfigDscr . . . . . . . . .  PUBLIC   DATA   U_INT    0008H  2
WAKEUPCS . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
CONFIGDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  config_len . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  interfaces . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  index. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  config_str . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  attrib . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  power. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
Selfpwr. . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
pDeviceQualDscr. . . . . . . . . . . .  PUBLIC   DATA   U_INT    000AH  2
DR_VendorCmnd. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
TD_Resume. . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
SETUPDAT . . . . . . . . . . . . . . .  EXTERN   XDATA  ARRAY    -----  8
EICON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
EPIOC. . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  cntrl. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bytes. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
I2CPCKT. . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  dat. . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  count. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  status . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
FullSpeedConfigDscr. . . . . . . . . .  EXTERN   CODE   STRUCT   -----  9
DR_SetFeature. . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
INTRFCDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
C51 COMPILER V9.54   FW                                                                    08/10/2015 22:26:05 PAGE 44  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  index. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  alt_setting. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  ep_cnt . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  class. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  interface_str. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
DeviceQualDscr . . . . . . . . . . . .  EXTERN   CODE   STRUCT   -----  10
USBIE. . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
ENDPNTDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  ep_type. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  mp_L . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  mp_H . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  interval . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
DR_GetConfiguration. . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
pStringDscr. . . . . . . . . . . . . .  PUBLIC   DATA   U_INT    000CH  2
Sleep. . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    942    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      16
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
